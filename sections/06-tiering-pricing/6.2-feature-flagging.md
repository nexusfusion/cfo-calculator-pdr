# 6.2 Feature Flagging Strategy

This section defines how feature flags control access to capabilities across the CFO Business Intelligence Calculator Suite. Feature flags enable gradual rollouts, A/B testing, tier-based gating, and tenant-specific overrides without code deployments.

---

## 1. Suite-Level Feature Flags

Suite-level flags control platform-wide features that apply across all calculators.

### Flag Naming Convention

**Format**: `suite_{feature_name}`

**Examples**:
- `suite_ai_enabled`: Master kill switch for all AI features (emergency disable if LLM costs spike)
- `suite_exports_enabled`: Master kill switch for exports (emergency disable if S3 costs spike)
- `suite_new_ui`: Gradual rollout of new UI design (percentage-based)
- `suite_beta_features`: Enable beta features for opted-in users

### Flag Types

**1. Boolean (On/Off)**

Simple enable/disable toggle.

```json
{
  "flag_name": "suite_ai_enabled",
  "type": "boolean",
  "value": true,
  "description": "Master AI feature toggle"
}
```

**Use case**: Kill switch for expensive or unstable features.

**Code example**:
```typescript
async function canUseAI(userId: string): Promise<boolean> {
  const aiEnabled = await getFlag('suite_ai_enabled');
  if (!aiEnabled) {
    return false; // AI globally disabled
  }

  const userTier = getUserTier(userId);
  return ['ai', 'b2b'].includes(userTier);
}
```

---

**2. Percentage Rollout**

Gradually release feature to percentage of users.

```json
{
  "flag_name": "suite_new_ui",
  "type": "percentage",
  "value": 25,
  "description": "Rollout new UI to 25% of users"
}
```

**Use case**: Test new features with small audience before full release.

**Code example**:
```typescript
function shouldShowNewUI(userId: string): boolean {
  const rolloutPercentage = getFlag('suite_new_ui').value; // 25
  const userHash = hashUserId(userId); // Deterministic hash
  const bucket = userHash % 100; // 0-99

  return bucket < rolloutPercentage; // 25% of users see new UI
}
```

**Deterministic hashing** ensures same user always sees same variant (no flip-flopping).

---

**3. User Segment**

Target specific user groups (e.g., Pro users only, specific tenant).

```json
{
  "flag_name": "suite_advanced_charts",
  "type": "segment",
  "value": {
    "tiers": ["pro", "ai", "b2b"],
    "tenants": ["acme_corp"],
    "user_ids": ["uuid-1234", "uuid-5678"]
  },
  "description": "Advanced charts for Pro+ tiers and specific test users"
}
```

**Use case**: Beta features for paying customers, dogfooding with internal users.

**Code example**:
```typescript
function canAccessAdvancedCharts(userId: string): boolean {
  const flag = getFlag('suite_advanced_charts');
  const user = getUser(userId);

  // Check tier
  if (flag.value.tiers.includes(user.tier)) return true;

  // Check tenant
  if (user.tenant_id && flag.value.tenants.includes(user.tenant_id)) return true;

  // Check specific user IDs (for testing)
  if (flag.value.user_ids.includes(userId)) return true;

  return false;
}
```

---

### Flag Management

**Options**:

**1. Third-party service** (recommended for Phase 2+):
- **LaunchDarkly**: Feature flag SaaS with real-time updates, targeting, A/B testing
- **Flagsmith**: Open-source alternative with self-hosted option
- **Advantages**: Web UI for non-engineers, instant flag changes (no deployment), advanced targeting
- **Cost**: $50-200/month depending on MAU

**2. Custom database table** (sufficient for Phase 1):
```sql
CREATE TABLE feature_flags (
  flag_name VARCHAR(255) PRIMARY KEY,
  flag_type VARCHAR(50) NOT NULL, -- 'boolean', 'percentage', 'segment'
  flag_value JSONB NOT NULL,
  enabled BOOLEAN DEFAULT true,
  description TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**Advantages**: No external dependency, free, full control
**Disadvantages**: Requires deployment to change flags (unless using admin dashboard)

**Phase 1 recommendation**: Start with database table + admin dashboard for flag management. Migrate to LaunchDarkly in Phase 2 if frequent flag changes needed.

---

## 2. Per-Calculator Feature Flags

Per-calculator flags control features specific to individual calculators.

### Flag Naming Convention

**Format**: `calc_{calculator_slug}_{feature_name}`

**Examples**:
- `calc_business_loan_advanced_charts`: New DSCR visualization charts for Business Loan Calculator
- `calc_cash_runway_sensitivity_views`: Sensitivity analysis for Cash Runway Calculator
- `calc_breakeven_multi_product`: Multi-product breakeven analysis (Phase 2 feature)

### Use Cases

**1. Gradual rollout of calculator-specific features**

Roll out new chart type to 10% of users, monitor performance, gradually increase to 100%.

```json
{
  "flag_name": "calc_business_loan_advanced_charts",
  "type": "percentage",
  "value": 10,
  "description": "Test advanced DSCR charts with 10% of users"
}
```

**Implementation**:
```typescript
function BusinessLoanCalculator({ scenario }) {
  const showAdvancedCharts = shouldShowFeature(
    'calc_business_loan_advanced_charts',
    user.id
  );

  return (
    <>
      {/* Standard results */}
      <ResultCard label="DSCR" value={scenario.dscr} />

      {/* Conditionally show advanced charts */}
      {showAdvancedCharts && <DSCRTrendChart data={scenario.history} />}
    </>
  );
}
```

---

**2. Beta features for specific calculators**

Enable Phase 2 features for Pro users only (test with paying customers before GA).

```json
{
  "flag_name": "calc_valuation_monte_carlo",
  "type": "segment",
  "value": {
    "tiers": ["pro", "ai", "b2b"]
  },
  "description": "Monte Carlo simulation for Valuation Calculator (Pro+ only)"
}
```

---

**3. A/B testing calculator UI variants**

Test two versions of input form: Variant A (current) vs Variant B (simplified).

```json
{
  "flag_name": "calc_equipment_lease_simplified_form",
  "type": "percentage",
  "value": 50,
  "description": "A/B test simplified input form (50/50 split)"
}
```

**Metrics to track**:
- Calculation completion rate (Variant A vs B)
- Time to first calculation (Variant A vs B)
- User feedback scores

---

## 3. Tenant-Level Overrides (B2B)

B2B tenants can override feature flags and tier limits via tenant configuration.

### Tenant Config Schema

```json
{
  "tenant_id": "acme_corp",
  "tenant_name": "Acme Financial Advisors",
  "tier": "b2b",

  "features": {
    "ai_enabled": false,             // Disable AI (tenant policy)
    "max_scenarios_per_user": 100,   // Override default 50
    "custom_branding": true,
    "api_access": true,
    "white_label": true
  },

  "tier_overrides": {
    "all_users_pro": true            // All tenant users treated as Pro tier
  },

  "calculator_overrides": {
    "business_loan": {
      "enabled": true,
      "max_loan_amount": 10000000    // Calculator-specific limit
    },
    "cash_runway": {
      "enabled": false                // Disable specific calculator
    }
  }
}
```

**Storage**: `tenant_configs` table in PostgreSQL

---

### Priority Order

When determining feature access, check in this order:

1. **Tenant config** (highest priority)
2. **User tier** (Pro, AI, B2B)
3. **Default tier** (Free tier defaults)

**Example decision tree**:

```
User requests AI narrative
  ↓
Is user in a tenant?
  YES → Check tenant config: ai_enabled?
    YES → Allow (even if user tier is 'free', tenant overrides)
    NO → Block (tenant disabled AI)
  NO → Check user tier
    tier === 'ai' or 'b2b' → Allow
    tier === 'pro' or 'free' → Block with upgrade prompt
```

---

### Code Implementation

```typescript
function getTierConfig(userId: string): TierConfig {
  const user = getUser(userId);

  // Priority 1: Tenant config (if user belongs to tenant)
  if (user.tenant_id) {
    const tenant = getTenant(user.tenant_id);
    return {
      tier: tenant.tier_overrides.all_users_pro ? 'pro' : user.tier,
      features: tenant.features,
      limits: {
        max_scenarios: tenant.features.max_scenarios_per_user || 50,
        max_exports: tenant.features.max_exports_per_month || 100,
        ai_enabled: tenant.features.ai_enabled
      }
    };
  }

  // Priority 2: User tier (individual users)
  return getStandardTierConfig(user.tier);
}

function canAccessFeature(userId: string, feature: string): boolean {
  const config = getTierConfig(userId);

  // Check tenant-specific overrides first
  if (config.features && config.features[feature] !== undefined) {
    return config.features[feature];
  }

  // Fall back to tier-based access
  const tierFeatures = getTierFeatures(config.tier);
  return tierFeatures.includes(feature);
}
```

---

## Feature Flag Decision Tree

**Pseudocode for "Can user access AI narratives?"**:

```
function canAccessAI(userId: string): boolean {
  // Step 1: Check suite-level kill switch
  if (!getFlag('suite_ai_enabled')) {
    return false; // AI globally disabled
  }

  // Step 2: Check tenant config (if applicable)
  const user = getUser(userId);
  if (user.tenant_id) {
    const tenant = getTenant(user.tenant_id);
    if (tenant.features.ai_enabled === false) {
      return false; // Tenant disabled AI
    }
    if (tenant.features.ai_enabled === true) {
      return true; // Tenant enabled AI (overrides user tier)
    }
  }

  // Step 3: Check user tier
  if (['ai', 'b2b'].includes(user.tier)) {
    return true; // AI tier or B2B with AI enabled
  }

  // Step 4: Default to locked
  return false;
}
```

---

## Feature Flag Examples

### Example 1: Gradual Rollout of New Export Format

**Scenario**: Add Excel export support, roll out to 25% of Pro users, monitor S3 costs.

**Flag**:
```json
{
  "flag_name": "suite_excel_exports",
  "type": "percentage",
  "value": 25,
  "description": "Excel exports for 25% of Pro users"
}
```

**Code**:
```typescript
function getAvailableExportFormats(userId: string): string[] {
  const formats = ['pdf', 'csv'];

  const userTier = getUserTier(userId);
  if (!['pro', 'ai', 'b2b'].includes(userTier)) {
    return formats; // Free tier: PDF and CSV only
  }

  // Pro+ tier: Check Excel flag
  const excelEnabled = await getFlagForUser('suite_excel_exports', userId);
  if (excelEnabled) {
    formats.push('excel');
  }

  return formats;
}
```

**Rollout plan**:
1. Week 1: 10% rollout → monitor S3 costs, export latency
2. Week 2: 25% rollout → monitor user feedback
3. Week 3: 50% rollout
4. Week 4: 100% rollout → set flag to 100%, remove flag in next deploy

---

### Example 2: Beta Feature for Specific Tenant

**Scenario**: Acme Corp (B2B tenant) wants early access to Monte Carlo simulation before GA.

**Tenant config**:
```json
{
  "tenant_id": "acme_corp",
  "features": {
    "beta_features": true
  }
}
```

**Flag**:
```json
{
  "flag_name": "calc_valuation_monte_carlo",
  "type": "segment",
  "value": {
    "tenants": ["acme_corp"]
  },
  "description": "Monte Carlo for Acme Corp only (beta)"
}
```

**Code**:
```typescript
function shouldShowMonteCarloOption(userId: string): boolean {
  const flag = getFlag('calc_valuation_monte_carlo');
  const user = getUser(userId);

  // Check if user's tenant is in allowed list
  if (user.tenant_id && flag.value.tenants.includes(user.tenant_id)) {
    return true;
  }

  return false;
}
```

---

### Example 3: Kill Switch for Expensive AI Feature

**Scenario**: LLM API costs spike unexpectedly (rate limit exceeded, pricing change). Disable AI immediately without deployment.

**Flag**:
```json
{
  "flag_name": "suite_ai_enabled",
  "type": "boolean",
  "value": false,
  "description": "Emergency disable for AI features"
}
```

**Action**:
1. Admin logs into feature flag dashboard
2. Sets `suite_ai_enabled` to `false`
3. All AI requests immediately blocked (flag checked on every request)
4. Users see: "AI is temporarily unavailable. Try again later."

**Recovery**:
- Investigate LLM API issue
- Increase rate limits or optimize prompts
- Re-enable flag: `suite_ai_enabled = true`

---

## Flag Management Best Practices

**1. Document every flag**:
- Flag name, description, owner (who created it)
- Rollout plan (start at 10%, increase to 100%)
- Success metrics (what defines success?)
- Cleanup date (remove flag after 100% rollout)

**2. Clean up old flags**:
- After feature reaches 100% rollout, remove flag (deploy with feature always enabled)
- Flag cleanup sprints every quarter (remove unused flags)

**3. Test flag toggling**:
- Unit tests: "When flag is off, feature is hidden"
- Integration tests: "When flag is on for 50% of users, verify deterministic bucketing"

**4. Avoid flag sprawl**:
- Limit to 10-20 active flags at any time
- Use flags for risky features, not every minor change

**5. Monitor flag impact**:
- Track metrics per flag (e.g., "Excel export flag → 15% increase in export count")
- Alert if flag change causes error spike

---

## Summary

This feature flagging strategy provides:
- **Suite-level flags**: Platform-wide toggles (AI, exports, new UI)
- **Per-calculator flags**: Calculator-specific features (advanced charts, beta capabilities)
- **Tenant-level overrides**: B2B customization (disable AI, increase limits, enable beta features)
- **Priority order**: Tenant config > User tier > Default tier

Flags enable gradual rollouts, A/B testing, and emergency kill switches without code deployments. All flag checks enforced server-side (never trust client) with clear fallback behavior when flags are disabled.
