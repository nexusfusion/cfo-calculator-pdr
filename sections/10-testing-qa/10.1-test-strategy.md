# 10.1 Test Strategy (Suite-Level)

This section defines the comprehensive testing approach for the CFO Business Intelligence Calculator Suite across all levels, from unit tests to end-to-end workflows. The testing strategy ensures formula correctness, performance SLA compliance (Section 1.6), and regression safety.

---

## Testing Philosophy

**Goals**:
- **Formula correctness**: 100% accuracy for calculations (golden scenarios, Section 10.2)
- **Performance compliance**: Meet all SLAs (p95 <150ms calculations, <3s exports)
- **Regression safety**: Prevent breaking changes to formulas or features
- **User experience quality**: Ensure calculators work correctly across browsers, devices, and tiers

**Testing pyramid**:
```
         /\
        /E2E\        10% - End-to-End Tests (critical workflows)
       /------\
      /Integr.\     30% - Integration Tests (API, database, exports)
     /----------\
    /   Unit     \  60% - Unit Tests (formulas, validation, components)
   /--------------\
```

**Test-driven approach**: Write tests before or alongside implementation (not after).

---

## 1. Unit Testing

### Scope

**Individual functions and components**, tested in isolation without dependencies.

**What gets unit tested**:
- **Formula library**: All calculation functions (DSCR, amortization, runway, breakeven, valuation)
- **Input validation**: Range checks, type checks, business logic validation
- **Formatting utilities**: Currency formatting, percentage formatting, number formatting
- **UI components**: React components (inputs, result cards, scenario tabs, modals)
- **Helper functions**: Date utilities, math utilities, data transformations

**What does NOT get unit tested**:
- Database queries (tested in integration tests)
- API endpoints (tested in integration tests)
- External service calls (AI, Stripe - mocked in unit tests)

### Coverage Targets

**Required coverage levels**:

| Component Type | Coverage Target | Rationale |
|----------------|-----------------|-----------|
| Formula library | 100% | Core value proposition, must be correct |
| Input validation | 100% | Prevents bad data from corrupting calculations |
| Formatting utilities | 100% | Critical for export quality and UX |
| UI components | 80% minimum | Balance test value vs effort (some visual aspects hard to test) |
| API routes | 70% minimum | Core logic tested, edge cases in integration tests |

**Coverage enforcement**:
- CI/CD pipeline fails if coverage drops below targets
- Pre-commit hook warns if new code has <80% coverage
- Coverage report published with each pull request

### Tools

**JavaScript/TypeScript**:
- **Jest**: Test runner and assertion library
  - Fast, parallel execution
  - Built-in mocking and code coverage
  - React Testing Library for component tests

**Python** (if backend uses Python):
- **pytest**: Test runner
- **pytest-cov**: Coverage reporting

**Configuration**:
```json
{
  "jest": {
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      },
      "src/formulas/": {
        "branches": 100,
        "functions": 100,
        "lines": 100,
        "statements": 100
      }
    }
  }
}
```

### Example Unit Tests

**Test 1: Amortization formula with standard inputs**

```typescript
describe('calculateAmortization', () => {
  test('standard SBA loan: $250k at 7.5% for 10 years', () => {
    const inputs = {
      principal: 250000,
      annualRate: 0.075,
      termMonths: 120,
    };

    const result = calculateAmortization(inputs);

    expect(result.monthlyPayment).toBeCloseTo(2958.04, 2);
    expect(result.totalInterest).toBeCloseTo(104964.80, 2);
    expect(result.totalCost).toBeCloseTo(354964.80, 2);
    expect(result.version).toBe('v1');
  });

  test('short-term loan: $50k at 9% for 3 years', () => {
    const inputs = {
      principal: 50000,
      annualRate: 0.09,
      termMonths: 36,
    };

    const result = calculateAmortization(inputs);

    expect(result.monthlyPayment).toBeCloseTo(1589.04, 2);
    expect(result.totalInterest).toBeCloseTo(7205.44, 2);
  });
});
```

**Test 2: DSCR calculation with zero debt service (edge case)**

```typescript
describe('calculateDSCR', () => {
  test('handles zero debt service gracefully', () => {
    const inputs = {
      annualRevenue: 1000000,
      operatingExpenses: 800000,
      annualDebtPayment: 0,
    };

    const result = calculateDSCR(inputs);

    expect(result.dscr).toBe(Infinity);
    expect(result.warnings).toContainEqual({
      code: 'ZERO_DEBT_SERVICE',
      message: 'DSCR cannot be calculated with zero debt service.',
      severity: 'info',
    });
  });

  test('handles negative operating income', () => {
    const inputs = {
      annualRevenue: 500000,
      operatingExpenses: 600000, // Negative $100k operating income
      annualDebtPayment: 50000,
    };

    const result = calculateDSCR(inputs);

    expect(result.dscr).toBeLessThan(0);
    expect(result.warnings).toContainEqual({
      code: 'NEGATIVE_OPERATING_INCOME',
      message: 'Business has negative operating income. DSCR is not meaningful.',
      severity: 'critical',
    });
  });
});
```

**Test 3: Input validation rejects negative loan amounts**

```typescript
describe('validateLoanInputs', () => {
  test('rejects negative loan amount', () => {
    const inputs = {
      principal: -250000,
      annualRate: 0.075,
      termMonths: 120,
    };

    const result = validateLoanInputs(inputs);

    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Loan amount must be positive');
  });

  test('rejects interest rate outside 0-30% range', () => {
    const inputs = {
      principal: 250000,
      annualRate: 0.50, // 50% - unrealistic
      termMonths: 120,
    };

    const result = validateLoanInputs(inputs);

    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Interest rate must be between 0% and 30%');
  });

  test('accepts valid inputs', () => {
    const inputs = {
      principal: 250000,
      annualRate: 0.075,
      termMonths: 120,
    };

    const result = validateLoanInputs(inputs);

    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });
});
```

**Test 4: Currency formatter handles large numbers correctly**

```typescript
describe('formatCurrency', () => {
  test('formats standard amounts with commas and decimals', () => {
    expect(formatCurrency(2958.04)).toBe('$2,958.04');
    expect(formatCurrency(250000)).toBe('$250,000.00');
    expect(formatCurrency(1500000)).toBe('$1,500,000.00');
  });

  test('handles large numbers (millions, billions)', () => {
    expect(formatCurrency(1000000)).toBe('$1,000,000.00');
    expect(formatCurrency(1000000000)).toBe('$1,000,000,000.00');
  });

  test('handles small amounts (cents)', () => {
    expect(formatCurrency(0.99)).toBe('$0.99');
    expect(formatCurrency(0.01)).toBe('$0.01');
  });

  test('handles zero', () => {
    expect(formatCurrency(0)).toBe('$0.00');
  });

  test('handles negative amounts', () => {
    expect(formatCurrency(-2958.04)).toBe('-$2,958.04');
  });
});
```

**Test 5: React component rendering**

```typescript
describe('MetricCard component', () => {
  test('renders metric with label, value, and unit', () => {
    render(
      <MetricCard
        label="Monthly Payment"
        value={2958.04}
        unit="USD"
        format="currency"
      />
    );

    expect(screen.getByText('Monthly Payment')).toBeInTheDocument();
    expect(screen.getByText('$2,958.04')).toBeInTheDocument();
  });

  test('renders warning icon when warning prop is true', () => {
    render(
      <MetricCard
        label="DSCR"
        value={1.18}
        format="decimal"
        warning={true}
        warningMessage="DSCR below typical lender minimum of 1.25"
      />
    );

    expect(screen.getByRole('img', { name: /warning/i })).toBeInTheDocument();
    expect(screen.getByText(/DSCR below typical lender minimum/i)).toBeInTheDocument();
  });
});
```

---

## 2. Integration Testing

### Scope

**Multiple components working together**, including database, APIs, and external services.

**What gets integration tested**:
- **API endpoints**: Calculate, export, save scenario, AI request, user authentication
- **Database operations**: Save scenario, retrieve scenarios, update user tier, log events
- **Tier gating logic**: Free user attempts Pro feature, Pro user accesses locked AI feature
- **Export generation**: Inputs → calculation → PDF/CSV/Excel with correct formatting and watermarking
- **Payment flow**: Stripe webhook updates user tier correctly
- **AI integration**: Request AI narrative, receive response, handle timeout/errors

### Test Areas

**API endpoint testing**:
- Request/response format validation (JSON schema)
- Status codes (200 success, 400 bad request, 403 forbidden, 500 error)
- Authentication and authorization (valid token required, tier-based access)
- Performance (response time <200ms for calculations)

**Database testing**:
- CRUD operations (create, read, update, delete scenarios)
- Data integrity (foreign key constraints, unique constraints)
- Transaction rollback on errors

**Tier gating testing**:
- Free user cannot create second scenario (403 Forbidden)
- Pro user can create scenarios, access advanced metrics
- AI tier user can request AI narratives (up to quota)

**Export generation testing**:
- PDF includes all inputs, outputs, disclaimers
- Watermark present for Free tier, absent for Pro tier
- CSV has correct metadata headers
- Excel has formatted cells (currency, percentage)

### Tools

**API testing**:
- **Supertest**: HTTP assertions for Node.js/Express/Fastify
  - Programmatic API calls without starting server
  - Assertion helpers for status codes, response bodies

**Database testing**:
- **Test database**: Separate PostgreSQL instance for testing (not production)
- **Database migrations**: Run up/down migrations in tests
- **Test fixtures**: Seed test data before each test, clean up after

**Example configuration**:
```typescript
// Test setup
beforeAll(async () => {
  await db.migrate.latest(); // Run migrations
  await db.seed.run(); // Seed test data
});

afterAll(async () => {
  await db.destroy(); // Close database connection
});

beforeEach(async () => {
  await db('scenarios').del(); // Clear scenarios table
});
```

### Example Integration Tests

**Test 1: POST to /api/calculate returns correct results within 200ms**

```typescript
describe('POST /api/calculate', () => {
  test('calculates DSCR correctly and returns within 200ms', async () => {
    const startTime = Date.now();

    const response = await request(app)
      .post('/api/calculate')
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: {
          principal: 250000,
          annualRate: 7.5,
          termMonths: 120,
          annualRevenue: 1500000,
          operatingExpenses: 1200000,
        },
      })
      .expect(200);

    const duration = Date.now() - startTime;

    expect(response.body.outputs.monthlyPayment).toBeCloseTo(2958.04, 2);
    expect(response.body.outputs.dscr).toBeCloseTo(1.42, 2);
    expect(response.body.version).toBe('v1');
    expect(duration).toBeLessThan(200); // Performance check
  });

  test('returns 400 for invalid inputs', async () => {
    const response = await request(app)
      .post('/api/calculate')
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: {
          principal: -250000, // Invalid: negative
          annualRate: 7.5,
          termMonths: 120,
        },
      })
      .expect(400);

    expect(response.body.error).toContain('Loan amount must be positive');
  });
});
```

**Test 2: Save scenario as Pro user succeeds, as Free user fails with 403**

```typescript
describe('POST /api/scenarios', () => {
  test('Pro user can save scenario', async () => {
    const proUser = await createTestUser({ tier: 'pro' });
    const token = generateAuthToken(proUser);

    const response = await request(app)
      .post('/api/scenarios')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
      })
      .expect(201);

    expect(response.body.scenario_id).toBeDefined();

    // Verify scenario saved in database
    const saved = await db('scenarios').where({ scenario_id: response.body.scenario_id }).first();
    expect(saved).toBeDefined();
    expect(saved.user_id).toBe(proUser.user_id);
  });

  test('Free user receives 403 Forbidden', async () => {
    const freeUser = await createTestUser({ tier: 'free' });
    const token = generateAuthToken(freeUser);

    const response = await request(app)
      .post('/api/scenarios')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
      })
      .expect(403);

    expect(response.body.error).toContain('Upgrade to Pro to save scenarios');
  });
});
```

**Test 3: Export PDF includes watermark for Free tier, no watermark for Pro**

```typescript
describe('POST /api/exports', () => {
  test('Free tier export has watermark', async () => {
    const freeUser = await createTestUser({ tier: 'free' });
    const token = generateAuthToken(freeUser);

    const response = await request(app)
      .post('/api/exports')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
        format: 'pdf',
      })
      .expect(202); // Async export, returns 202 Accepted

    // Wait for export to complete
    await waitForExport(response.body.export_id);

    const exportRecord = await db('exports').where({ export_id: response.body.export_id }).first();
    expect(exportRecord.has_watermark).toBe(true);

    // Download PDF and verify watermark
    const pdfBuffer = await downloadExport(exportRecord.file_url);
    const pdfText = await extractTextFromPDF(pdfBuffer);
    expect(pdfText).toContain('Upgrade for clean exports');
  });

  test('Pro tier export has no watermark', async () => {
    const proUser = await createTestUser({ tier: 'pro' });
    const token = generateAuthToken(proUser);

    const response = await request(app)
      .post('/api/exports')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
        format: 'pdf',
      })
      .expect(202);

    await waitForExport(response.body.export_id);

    const exportRecord = await db('exports').where({ export_id: response.body.export_id }).first();
    expect(exportRecord.has_watermark).toBe(false);

    const pdfBuffer = await downloadExport(exportRecord.file_url);
    const pdfText = await extractTextFromPDF(pdfBuffer);
    expect(pdfText).not.toContain('Upgrade for clean exports');
  });
});
```

**Test 4: AI request returns narrative within 5 seconds or timeout error**

```typescript
describe('POST /api/ai/narrative', () => {
  test('returns AI narrative within 5 seconds', async () => {
    const aiUser = await createTestUser({ tier: 'ai' });
    const token = generateAuthToken(aiUser);

    const startTime = Date.now();

    const response = await request(app)
      .post('/api/ai/narrative')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        request_type: 'explain_result',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
      })
      .expect(200);

    const duration = Date.now() - startTime;

    expect(response.body.narrative).toBeDefined();
    expect(response.body.narrative).toContain('DSCR'); // Response mentions DSCR
    expect(duration).toBeLessThan(5000); // Within 5 seconds
  });

  test('returns timeout error if AI takes >8 seconds', async () => {
    // Mock AI provider to delay 10 seconds
    mockAnthropicAPI.delay(10000);

    const aiUser = await createTestUser({ tier: 'ai' });
    const token = generateAuthToken(aiUser);

    const response = await request(app)
      .post('/api/ai/narrative')
      .set('Authorization', `Bearer ${token}`)
      .send({
        calculator_slug: 'business-loan-dscr',
        request_type: 'explain_result',
        inputs: { principal: 250000, annualRate: 7.5, termMonths: 120 },
        outputs: { monthlyPayment: 2958.04, dscr: 1.42 },
      })
      .expect(504); // Gateway Timeout

    expect(response.body.error).toContain('AI request timed out');
  });
});
```

---

## 3. End-to-End Testing

### Scope

**Complete user workflows** from browser interaction to backend processing, simulating real user behavior.

**What gets E2E tested**:
- **Free tier workflow**: View calculator, enter inputs, see results, attempt export (blocked), see upgrade prompt
- **Pro tier workflow**: Create multiple scenarios, compare side-by-side, export clean PDF
- **AI tier workflow**: Request AI explanation, receive narrative, stay within monthly cap
- **Upgrade workflow**: Click upgrade, complete Stripe checkout, features unlock immediately
- **Cross-browser compatibility**: Chrome, Safari, Firefox, Edge
- **Mobile responsiveness**: Tablet (iPad) and mobile (iPhone) viewports

### Test Scenarios

**Scenario 1: Free tier workflow**

```
1. User navigates to /calculators/business-loan-dscr
2. User enters loan amount ($250,000), interest rate (7.5%), term (10 years)
3. Calculator displays monthly payment ($2,958.04) and DSCR (if revenue/expenses entered)
4. User clicks "Add Scenario" → Upgrade prompt shown with tier comparison
5. User clicks "Export" → PDF generated with watermark
6. User sees upgrade CTA on export modal
```

**Scenario 2: Pro tier workflow**

```
1. Pro user logs in
2. User navigates to /calculators/business-loan-dscr
3. User creates Scenario 1 (10-year term), Scenario 2 (15-year term)
4. User switches between scenario tabs, sees side-by-side comparison
5. User clicks "Export" → Clean PDF generated (no watermark)
6. User downloads PDF, verifies correct inputs/outputs
```

**Scenario 3: AI tier workflow**

```
1. AI tier user logs in
2. User navigates to /calculators/business-loan-dscr
3. User enters inputs, sees results
4. User clicks "Explain this result" → AI narrative displayed
5. User sees AI quota: "49 of 50 requests remaining"
6. User clicks "Explain" again → Another narrative shown
7. User sees "48 of 50 requests remaining"
```

**Scenario 4: Upgrade workflow**

```
1. Free user logs in
2. User clicks locked feature (e.g., "Add Scenario")
3. Upgrade modal shown with "Upgrade to Pro for $29/month"
4. User clicks "Upgrade Now" → Redirected to Stripe checkout
5. User enters payment details, submits
6. User redirected back to app, sees "Upgrade successful" message
7. User can now access Pro features (create scenarios, clean exports)
```

### Tools

**Browser automation**:
- **Playwright** (preferred): Fast, reliable, multi-browser support
  - Supports Chrome, Firefox, Safari, Edge
  - Mobile viewport emulation
  - Screenshot and video recording for debugging
  - Auto-waiting (no explicit waits needed)

**Alternative**:
- **Cypress**: Good developer experience, Chrome/Firefox only

**Test execution**:
- Run locally during development
- Run in CI/CD on every pull request
- Run nightly for full cross-browser suite

### Cross-Browser Testing

**Browsers tested**:
- **Chrome**: Latest version (primary)
- **Safari**: Latest version (macOS/iOS)
- **Firefox**: Latest version
- **Edge**: Latest version (Windows)

**Test matrix** (examples):
| Test Scenario | Chrome | Safari | Firefox | Edge |
|---------------|--------|--------|---------|------|
| Free tier workflow | ✓ | ✓ | ✓ | ✓ |
| Pro tier workflow | ✓ | ✓ | ✓ | ✓ |
| AI tier workflow | ✓ | ✓ | ✓ | ✓ |
| Upgrade workflow | ✓ | - | ✓ | - |

**Mobile responsive testing**:
- **Tablet**: iPad (1024×768)
- **Mobile**: iPhone (375×667)
- **Tests**: Calculator renders correctly, inputs are usable, results are readable

### Example E2E Tests

**Test: Free tier workflow**

```typescript
test('Free user can view calculator, calculate, see upgrade prompt', async ({ page }) => {
  // Navigate to calculator
  await page.goto('/calculators/business-loan-dscr');

  // Verify calculator loaded
  await expect(page.getByText('Business Loan + DSCR Calculator')).toBeVisible();

  // Enter inputs
  await page.fill('input[name="principal"]', '250000');
  await page.fill('input[name="annualRate"]', '7.5');
  await page.fill('input[name="termYears"]', '10');

  // Results appear automatically (debounced calculation)
  await expect(page.getByText('$2,958.04')).toBeVisible({ timeout: 5000 });

  // Click "Add Scenario" → Upgrade prompt shown
  await page.click('button:has-text("Add Scenario")');
  await expect(page.getByText('Upgrade to Pro')).toBeVisible();
  await expect(page.getByText('$29/month')).toBeVisible();

  // Close modal
  await page.click('button:has-text("Not now")');

  // Click "Export" → Watermark warning shown
  await page.click('button:has-text("Export")');
  await page.click('button:has-text("Download PDF")');
  await expect(page.getByText('watermarked')).toBeVisible();
});
```

**Test: Pro tier workflow (multi-scenario)**

```typescript
test('Pro user can create multiple scenarios and compare', async ({ page }) => {
  // Login as Pro user
  await loginAsProUser(page);

  await page.goto('/calculators/business-loan-dscr');

  // Create Scenario 1 (10-year term)
  await page.fill('input[name="principal"]', '250000');
  await page.fill('input[name="annualRate"]', '7.5');
  await page.fill('input[name="termYears"]', '10');
  await page.click('button:has-text("Save Scenario")');
  await expect(page.getByText('Scenario 1')).toBeVisible();

  // Create Scenario 2 (15-year term)
  await page.click('button:has-text("Add Scenario")');
  await page.fill('input[name="termYears"]', '15'); // Other inputs same
  await page.click('button:has-text("Save Scenario")');
  await expect(page.getByText('Scenario 2')).toBeVisible();

  // Switch to Scenario 1 tab
  await page.click('text=Scenario 1');
  await expect(page.getByText('$2,958.04')).toBeVisible();

  // Switch to Scenario 2 tab
  await page.click('text=Scenario 2');
  await expect(page.getByText('$2,247')).toBeVisible(); // Lower payment (longer term)

  // Export clean PDF (no watermark)
  await page.click('button:has-text("Export")');
  const downloadPromise = page.waitForEvent('download');
  await page.click('button:has-text("Download PDF")');
  const download = await downloadPromise;
  expect(download.suggestedFilename()).toContain('.pdf');
});
```

---

## 4. Performance and Load Testing

### Scope

**Verify SLAs under realistic and peak load conditions** (Section 1.6).

**What gets performance tested**:
- **Calculation engine**: Latency under concurrent load (p50, p95, p99)
- **Export service**: PDF/CSV generation time under load
- **AI service**: AI request latency and timeout behavior
- **Database**: Query performance under concurrent read/write operations
- **End-to-end**: Full user workflow latency (view → calculate → export)

### Test Scenarios

**Scenario 1: Calculation engine load**

**Setup**:
- 100 concurrent users
- Each user makes 10 calculation requests (1,000 total requests)
- Mixed calculator types (DSCR, runway, breakeven, valuation)

**Success criteria**:
- p50 latency <100ms
- p95 latency <150ms (SLA target)
- p99 latency <300ms
- Error rate <1%

**Scenario 2: Export service load**

**Setup**:
- 50 concurrent users
- Each user requests PDF export
- Mixture of simple (single scenario) and complex (multi-scenario) exports

**Success criteria**:
- p50 generation time <2 seconds
- p95 generation time <3 seconds (SLA target)
- p99 generation time <5 seconds
- Export failure rate <2%

**Scenario 3: AI service load**

**Setup**:
- 20 concurrent users (lower than calculation load, AI is slower)
- Each user requests AI narrative
- Mixed request types (explain_result, suggest_scenario)

**Success criteria**:
- p50 latency <2 seconds
- p95 latency <3 seconds (SLA target)
- p99 latency <5 seconds
- Timeout rate <5% (8-second timeout)

### Tools

**Load testing frameworks**:
- **k6** (preferred): JavaScript-based, open-source, excellent reporting
  - Scenarios defined in JavaScript
  - Real-time metrics (latency percentiles, throughput, error rate)
  - Cloud execution option (k6 Cloud)

**Alternative**:
- **Apache JMeter**: Java-based, GUI for test design
- **Artillery**: Node.js-based, YAML configuration

**Example k6 test**:
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up to 100 users over 2 minutes
    { duration: '5m', target: 100 }, // Stay at 100 users for 5 minutes
    { duration: '2m', target: 0 },   // Ramp down to 0 users
  ],
  thresholds: {
    'http_req_duration': ['p95<150'], // p95 latency <150ms
    'http_req_failed': ['rate<0.01'], // Error rate <1%
  },
};

export default function () {
  const payload = JSON.stringify({
    calculator_slug: 'business-loan-dscr',
    inputs: {
      principal: 250000,
      annualRate: 7.5,
      termMonths: 120,
    },
  });

  const res = http.post('https://api.example.com/api/calculate', payload, {
    headers: { 'Content-Type': 'application/json' },
  });

  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time <150ms': (r) => r.timings.duration < 150,
  });

  sleep(1); // Think time between requests
}
```

### When to Run Load Tests

**Frequency**:
- **Before each major release** (M1, M2, M3)
- **After infrastructure changes** (database upgrade, hosting migration)
- **Monthly** (baseline performance tracking)

**Continuous monitoring**:
- Production monitoring (APM tools like Datadog) tracks real-user latency
- Alerts if p95 latency exceeds SLA thresholds

---

## Summary

The test strategy for the CFO Business Intelligence Calculator Suite includes:

**1. Unit Testing** (60% of tests):
- Formula library: 100% coverage (critical for correctness)
- Input validation: 100% coverage (prevent bad data)
- UI components: 80% coverage (balance value vs effort)
- Tools: Jest, React Testing Library

**2. Integration Testing** (30% of tests):
- API endpoints, database operations, tier gating, export generation
- Verify components work together correctly
- Tools: Supertest, test database

**3. End-to-End Testing** (10% of tests):
- Complete user workflows (Free, Pro, AI, upgrade)
- Cross-browser (Chrome, Safari, Firefox, Edge)
- Mobile responsive (tablet, mobile)
- Tools: Playwright

**4. Performance and Load Testing**:
- Verify SLAs under load (p95 <150ms calculations, <3s exports)
- Run before major releases
- Tools: k6

**Coverage targets enforced in CI/CD**, blocking merge if tests fail or coverage drops below thresholds.
