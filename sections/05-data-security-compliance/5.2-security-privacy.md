# 5.2 Security & Privacy Baselines

This section defines the security and privacy standards for the CFO Business Intelligence Calculator Suite. These baselines ensure protection of user data, prevention of abuse, and compliance with privacy regulations (GDPR, CCPA) while maintaining the product's positioning as a decision-support tool with minimal PII exposure (per Section 1.7).

---

## 1. Authentication and Authorization

### Anonymous Session Management

**Cookie-based sessions**:
- **Session ID**: UUID v4, stored in httpOnly cookie (not accessible via JavaScript)
- **Cookie attributes**:
  - `HttpOnly: true` (prevents XSS attacks from stealing session ID)
  - `Secure: true` (HTTPS only, prevents MITM attacks)
  - `SameSite: Lax` (CSRF protection, allows navigation from external sites)
- **Expiry**: 30 days of inactivity (rolling expiration on each request)
- **Storage**: Redis (session ID → session data) or PostgreSQL sessions table

**Session data** (stored server-side):
```json
{
  "session_id": "uuid-v4",
  "created_at": "2025-01-15T14:30:00Z",
  "last_seen": "2025-01-15T16:45:00Z",
  "tier": "free",
  "locale": "en-US",
  "temp_scenarios": ["uuid-1", "uuid-2"] // Unsaved scenarios (deleted after 24 hours)
}
```

**Security considerations**:
- Session IDs are cryptographically random (UUID v4, 128-bit entropy)
- Session IDs never appear in URLs (prevents leakage via Referer headers)
- Sessions invalidated on logout (explicit) or 30 days inactivity (automatic)

---

### User Authentication (Email/Password and OAuth)

**Email/password authentication**:
- **Password requirements**:
  - Minimum 8 characters
  - No maximum length (up to 128 characters)
  - No complexity requirements (passphrases encouraged over complex passwords)
- **Password hashing**: bcrypt with cost factor 12 or Argon2id (OWASP recommendation)
- **Password reset flow**:
  - User requests reset → email sent with time-limited token (1-hour expiry)
  - Token is single-use (invalidated after use or expiry)
  - Token stored as bcrypt hash in database (not plaintext)

**OAuth authentication** (Google, Microsoft, GitHub):
- **OAuth 2.0 Authorization Code flow** (not Implicit flow, which is deprecated)
- **State parameter**: CSRF protection (random token stored in session, verified on callback)
- **Scope requests**: Minimal scopes (email, profile only; no access to user's data)
- **Account linking**: If user signs up with email/password, can link OAuth accounts later

**Multi-factor authentication (MFA)** (Phase 2+ feature):
- TOTP-based (Google Authenticator, Authy)
- Required for Admin users in B2B tenants
- Optional for individual Pro users

---

### Role-Based Access Control (RBAC)

**Roles**:

| Role | Scope | Permissions |
|------|-------|-------------|
| **Anonymous** | Session-scoped | Use calculators, save temp scenarios (24h), export (watermarked) |
| **User (Free)** | Account-scoped | Save 1 scenario permanently, export (watermarked), basic metrics |
| **User (Pro)** | Account-scoped | Save 10 scenarios, export (clean), advanced metrics, sharing |
| **User (AI)** | Account-scoped | Pro + AI narratives (50/month) |
| **Tenant User** | Tenant-scoped | Create scenarios within tenant, export, share with tenant members |
| **Tenant Admin** | Tenant-scoped | Manage tenant users, configure branding, view all tenant scenarios |
| **System Admin** | Platform-scoped | Impersonate users (with audit log), manage tenants, access dashboards (Section 1.8) |

**Permission checks**:
- Server-side enforcement (never trust client)
- Every API request checks: "Does this user have permission to perform this action on this resource?"
- Example: Viewing scenario requires: `scenario.user_id == current_user.id` OR `scenario.tenant_id == current_user.tenant_id && scenario.shared == true`

---

### API Authentication

**Web app (browser-based)**:
- **Session cookies** (as described above)
- **CSRF tokens**: Required for state-changing operations (POST, PUT, DELETE)
  - CSRF token stored in cookie (`XSRF-TOKEN`), sent in request header (`X-XSRF-Token`)
  - Framework-level CSRF protection (e.g., Fastify CSRF plugin)

**B2B API access (programmatic)**:
- **API keys**: UUID v4, generated per tenant
- **API key format**: `sk_live_abcd1234...` (prefix indicates environment: `sk_live`, `sk_test`)
- **Storage**: API keys hashed (SHA-256) in database, plaintext shown only once on generation
- **Authentication header**: `Authorization: Bearer sk_live_abcd1234...`
- **Scopes**: API keys scoped to tenant (can only access tenant's data)
- **Rotation**: Tenants can rotate API keys via dashboard (old key revoked, new key generated)
- **Rate limiting**: Stricter limits for API keys (per Section 5.2.5)

---

## 2. Data Encryption

### Encryption in Transit

**TLS 1.2+ for all connections**:
- **HTTPS only**: All HTTP requests redirected to HTTPS (301 permanent redirect)
- **TLS versions**: TLS 1.2 minimum, TLS 1.3 preferred
- **Cipher suites**: Strong ciphers only (ECDHE-RSA-AES128-GCM-SHA256 or better)
- **HSTS header**: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
- **Certificate**: Automated renewal via Let's Encrypt or AWS Certificate Manager

**API calls to external services**:
- LLM APIs (OpenAI, Anthropic): HTTPS only
- Payment providers (Stripe): HTTPS only, validate SSL certificates

**Database connections**:
- PostgreSQL: `sslmode=require` (TLS required)
- Redis: TLS enabled if Redis server supports it (optional for Redis on localhost)

---

### Encryption at Rest

**Database encryption**:
- **PostgreSQL**: Transparent Data Encryption (TDE) if supported by hosting provider (AWS RDS, Railway)
  - Otherwise: OS-level disk encryption (LUKS on Linux, encrypted EBS volumes on AWS)
- **Redis**: Encryption at rest via cloud provider (AWS ElastiCache, Upstash encryption)

**File storage encryption** (S3/Cloudflare R2):
- **Server-side encryption**: AES-256 (S3-managed keys or customer-managed keys via KMS)
- **Export files**: All PDF/CSV/Excel files encrypted at rest automatically
- **Access control**: S3 bucket policies restrict access (only application servers can read/write)

**Backup encryption**:
- Database backups encrypted (AWS RDS automated backups, or manual pg_dump encrypted with GPG)
- Export file backups (if needed) encrypted

---

### Key Management

**Encryption key rotation**:
- **Application secrets** (API keys, JWT secrets): Rotate every 90 days
- **Database encryption keys**: Rotate annually (or per cloud provider recommendation)
- **OAuth client secrets**: Rotate every 180 days

**Key storage**:
- **Environment variables**: Secrets stored in environment variables (not committed to Git)
- **Secrets manager**: AWS Secrets Manager, Railway Secrets, or HashiCorp Vault (Phase 2+)
- **Access controls**: Only application servers and authorized DevOps personnel can access secrets

**Key access audit**:
- Log all access to secrets manager (who accessed which secret, when)
- Alert on unexpected access (e.g., secret accessed from unknown IP)

---

## 3. Privacy and PII Handling

### What is PII in This System

**PII fields** (must be protected):
- **Email address**: Only PII field for registered users
- **Name**: Optional (user can provide name for Pro tier invoices, but not required for product use)

**NOT PII** (per Section 1.7 constraints):
- Scenario inputs: Aggregated financial data (loan amount, revenue, expenses) without customer names or account numbers
- Session IDs: Pseudonymous UUIDs, not reversible to user identity
- User IDs: Pseudonymous UUIDs, not directly tied to email in analytics

**Special case: B2B tenant names**:
- Tenant names (e.g., "Acme Financial Advisors") are business identifiers, not individual PII
- Treated as confidential but not subject to GDPR individual data rights

---

### PII Exclusion from Logs and Analytics

**Analytics events** (Section 5.1.5):
- **Never log**: Email addresses, names, IP addresses (except hashed)
- **Pseudonymous IDs only**: `user_id` (UUID), `session_id` (UUID)
- **IP addresses**: Hashed with SHA-256 before logging (for abuse detection only, not reversible)

**Application logs** (error logs, access logs):
- **Scrub PII**: Email addresses replaced with `[email]` or user ID
- **Example**:
  - Bad: `User user@example.com failed login attempt`
  - Good: `User uuid-1234 failed login attempt`

**AI request logs** (Section 5.4.2):
- **No user content**: Do not log scenario inputs/outputs sent to LLM (redact before logging)
- **Log metadata only**: User ID, calculator ID, request timestamp, response time, cost

---

### Pseudonymization Strategy

**User IDs**:
- UUIDs generated on user creation (e.g., `550e8400-e29b-41d4-a716-446655440000`)
- No reversible link to email in analytics database (email stored only in `users` table)

**Session IDs**:
- UUIDs generated on session creation
- Anonymous users tracked via session ID only (no link to email)

**Hashed identifiers** (for abuse detection):
- IP addresses: SHA-256 hash with salt (e.g., `sha256(ip_address + secret_salt)`)
- Browser fingerprints: SHA-256 hash (for rate limiting, not user tracking)

**Analytics queries**:
- Queries use `user_id` for cohort analysis (e.g., "How many users signed up in Jan 2025?")
- No joins to `users.email` in analytics queries (keep analytics pseudonymous)

---

### User Data Export (GDPR/CCPA Right to Access)

**GDPR Article 15 / CCPA 1798.110**: Users can request copy of their data.

**Data export format**:
```json
{
  "user_id": "uuid-1234",
  "email": "user@example.com",
  "tier": "pro",
  "signup_date": "2025-01-01T00:00:00Z",
  "scenarios": [
    {
      "scenario_id": "uuid-5678",
      "calculator_id": "business-loan",
      "created_at": "2025-01-15T14:30:00Z",
      "inputs": { /* full inputs */ },
      "outputs": { /* full outputs */ }
    }
    // ... all scenarios
  ],
  "exports": [
    {
      "export_id": "uuid-9012",
      "format": "pdf",
      "created_at": "2025-01-15T16:45:00Z",
      "download_url": "presigned-url-valid-for-7-days"
    }
    // ... all exports
  ],
  "analytics_summary": {
    "total_calculations": 123,
    "total_exports": 45,
    "last_login": "2025-01-20T10:00:00Z"
  }
}
```

**Export process**:
1. User requests data export via account settings
2. System generates JSON file (async job, ~30 seconds)
3. Email download link to user (presigned URL, 7-day expiry)

---

### User Data Deletion (GDPR/CCPA Right to Erasure)

**GDPR Article 17 / CCPA 1798.105**: Users can request deletion of their data.

**Hard delete process**:
1. User requests deletion via account settings or support ticket
2. System marks account for deletion (`deletion_requested_at` timestamp)
3. Grace period: 30 days (user can cancel deletion request)
4. After 30 days, hard delete:
   - Delete all scenarios (inputs, outputs, metadata)
   - Delete all exports (S3 files and database records)
   - Delete user record (email, password hash, all PII)
   - **Retain**: Pseudonymous analytics events (user_id retained but unlinked to email)

**Exceptions** (legal retention requirements):
- Invoices and payment records (retained for 7 years per tax law)
- Audit logs (retained for 24 months per Section 5.4)
- Aggregated analytics (no individual data, GDPR exemption)

**B2B tenant deletion**:
- When tenant cancels, all tenant users and scenarios deleted
- Tenant admin receives 30-day grace period (can export all data before deletion)

---

## 4. Input Validation and Sanitization

### Client-Side Validation (UX Feedback Only)

**Purpose**: Provide instant feedback to users (don't wait for server response)

**Validation rules**:
- Input type checking (number, string, email format)
- Range checking (loan amount > 0, interest rate 0-50%)
- Required field checks (disable "Calculate" button if required fields empty)

**NOT security-critical**:
- Client-side validation can be bypassed (user can modify JavaScript, send raw API requests)
- Never trust client-side validation alone

---

### Server-Side Validation (Security-Critical)

**Never trust client**: All inputs validated server-side.

**Validation framework**:
- JSON Schema validation (via AJV library or similar)
- Type checking: Ensure `loan_amount` is number, `payment_frequency` is string enum
- Range checking: Reject `loan_amount < 0`, `interest_rate < 0 || interest_rate > 0.5`
- Max length checks: Scenario names ≤ 30 characters, descriptions ≤ 500 characters

**Validation errors**:
- Return 400 Bad Request with detailed error messages
- Example: `{"error": "Invalid input", "details": {"loan_amount": "Must be greater than 0"}}`

---

### SQL Injection Prevention

**Use ORMs or parameterized queries** (never string concatenation):

**Good (parameterized query)**:
```typescript
// Using Prisma ORM
const scenario = await prisma.scenario.findUnique({
  where: { id: scenarioId }
});

// Or using pg library (parameterized)
const result = await client.query(
  'SELECT * FROM scenarios WHERE id = $1',
  [scenarioId]
);
```

**Bad (string concatenation, vulnerable to SQL injection)**:
```typescript
// NEVER DO THIS
const query = `SELECT * FROM scenarios WHERE id = '${scenarioId}'`;
await client.query(query); // Attacker can inject: scenarioId = "'; DROP TABLE scenarios; --"
```

**ORM preference**:
- Use Prisma, TypeORM, or Sequelize (all prevent SQL injection by default)
- If raw SQL needed, always use parameterized queries (`$1`, `$2` placeholders)

---

### XSS Prevention

**Escape all user-provided content**:

**React default behavior**:
- React escapes JSX expressions by default: `<div>{userInput}</div>` is safe
- Never use `dangerouslySetInnerHTML` with user input

**Server-side rendering**:
- Use templating engines with auto-escaping (Handlebars, EJS with `<%=` not `<%-`)
- Example: `<p>{{ scenario_name }}</p>` (Handlebars escapes by default)

**AI-generated content** (special case):
- AI narratives may include formatting (bold, italic)
- Sanitize AI output with DOMPurify library (allow safe HTML tags: `<b>`, `<i>`, `<p>`, but strip `<script>`, `<iframe>`)

**Content Security Policy (CSP) header**:
```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.example.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; frame-ancestors 'none';
```
- `script-src 'self'`: Only scripts from same origin (no inline scripts except whitelisted)
- `frame-ancestors 'none'`: Prevent clickjacking (page cannot be embedded in iframe)

---

## 5. Rate Limiting and Abuse Prevention

### Calculation Rate Limits

**Anonymous users** (per session):
- 100 calculations per hour
- Enforced via Redis counter: `rate_limit:calc:{session_id}` with 1-hour TTL

**Registered users (Free tier)**:
- 500 calculations per hour
- Prevents abuse while allowing normal use (50-100 calculations per session is typical)

**Pro tier and B2B**:
- 5,000 calculations per hour (effectively unlimited for normal use)

**Implementation**:
```typescript
const key = `rate_limit:calc:${sessionId}`;
const count = await redis.incr(key);
if (count === 1) {
  await redis.expire(key, 3600); // 1 hour
}
if (count > 100) {
  throw new Error('Rate limit exceeded. Try again in 1 hour.');
}
```

---

### Export Rate Limits

**Free tier**:
- 10 exports per day (resets at midnight UTC)
- Prevents abuse of export system (storage costs, server load)

**Pro tier**:
- 100 exports per day

**B2B tier**:
- Configurable per tenant (default: 500 exports per day)

**Implementation**:
- Redis counter: `rate_limit:export:{user_id}:{date}` (e.g., `rate_limit:export:uuid-1234:2025-01-15`)
- TTL: 24 hours

---

### AI Request Rate Limits

**Free tier**:
- 0 AI requests (feature locked)

**Pro tier**:
- 0 AI requests (AI add-on required)

**AI add-on tier**:
- 50 AI requests per billing month (resets on subscription renewal date)
- Soft cap: Warn user at 45/50 requests
- Hard cap: Block at 50/50 requests, show upgrade message

**Implementation**:
- Database counter: `ai_usage` table with `user_id`, `billing_month`, `request_count`
- Incremented on each AI request
- Reset monthly via cron job (or on-demand when user's billing cycle resets)

---

### DDoS Protection

**Cloudflare or similar CDN**:
- Layer 3/4 DDoS protection (SYN floods, UDP floods)
- Layer 7 DDoS protection (HTTP floods, slowloris attacks)
- Rate limiting at edge (block IPs making > 1000 requests/minute)

**Application-level protections**:
- Rate limiting (as described above)
- Connection limits (max 1000 concurrent connections per IP)
- Request size limits (max 10MB request body)

**Monitoring**:
- Alert if request rate exceeds 10,000 requests/minute (indicates attack)
- Automatic IP blocking (via Cloudflare or fail2ban) for IPs with excessive failed requests

---

## Summary

These security and privacy baselines ensure:
- **Authentication**: Secure session management, strong password hashing, OAuth support
- **Authorization**: Role-based access control enforced server-side
- **Encryption**: TLS 1.2+ for all connections, AES-256 for data at rest
- **Privacy**: Minimal PII (email only), pseudonymous analytics, GDPR/CCPA data export/deletion
- **Input validation**: Server-side validation, SQL injection prevention, XSS prevention
- **Rate limiting**: Prevent abuse of calculations, exports, AI requests, DDoS attacks

All security measures are enforced server-side (never trust client) and logged for audit purposes.
