# 3.1 Architecture Layers

The CFO Business Intelligence Calculator Suite is built on a 7-layer architecture designed for modularity, scalability, and clear separation of concerns. This architecture supports the performance SLAs defined in Section 1.6 (p95 calculation < 150ms, exports < 3s, AI < 3s) while maintaining flexibility for embedding, multi-tenancy, and future platform expansion.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT LAYER                            │
│  WordPress Embeds | Standalone Web App | Future Mobile         │
└────────────────────────────┬────────────────────────────────────┘
                             │ HTTPS
┌────────────────────────────▼────────────────────────────────────┐
│                   API GATEWAY / BACKEND SERVICES                │
│  REST API | Auth | Rate Limiting | Tier Gating                 │
└────┬───────────────────────┬──────────────────────┬─────────────┘
     │                       │                      │
     │ RPC/Function Call     │ Queue Message        │ Event Stream
     │                       │                      │
┌────▼──────────┐  ┌────────▼────────┐  ┌──────────▼──────────┐
│  CALCULATION  │  │ EXPORT/REPORTING │  │   AI SERVICES       │
│    ENGINE     │  │    SERVICES      │  │  Prompt Mgmt, LLM   │
└────┬──────────┘  └────────┬─────────┘  └──────────┬──────────┘
     │                      │                       │
     │ DB Read/Write        │ File Storage          │ Logging
     │                      │                       │
┌────▼──────────────────────▼───────────────────────▼──────────┐
│                      DATA STORAGE                             │
│  PostgreSQL (Scenarios, Users) | Redis (Sessions, Cache)     │
│  S3/R2 (Export Files)                                         │
└────────────────────────────────┬──────────────────────────────┘
                                 │
                        ┌────────▼────────┐
                        │   ANALYTICS /   │
                        │   TELEMETRY     │
                        │  Event Tracking │
                        └─────────────────┘
```

---

## 1. Client Layer

### Purpose and Responsibilities

The client layer is the user-facing interface where calculators are rendered and users interact with inputs, outputs, and exports. This layer is responsible for:
- Rendering calculator UI (input forms, output tables, charts)
- Capturing user input and triggering calculations
- Displaying results, warnings, and AI narratives
- Handling tier-specific UI (Free tier upgrade prompts, Pro tier features, AI add-on commentary)
- Managing client-side state (current scenario, input values, unsaved changes)

### Components

- **WordPress Plugin/Shortcode**: Embeds calculators into WordPress sites via shortcodes (e.g., `[smart-calculator id="business-loan"]`)
- **Standalone Web App**: Full-featured React application hosted on dedicated domain (e.g., `calculators.smartprofit.com`)
- **Shared React Components**: Calculator shell, input panels, result cards, scenario tabs, export buttons (consumed by both WordPress and standalone)
- **Future Mobile Apps**: iOS/Android apps using the same backend API (Phase 3+)

### Communication Patterns

- **Calls API Gateway** via HTTPS REST endpoints:
  - `POST /api/calculators/:id/calculate` - Submit inputs, receive calculation results
  - `GET /api/scenarios/:id` - Load saved scenario
  - `POST /api/scenarios` - Save new scenario
  - `POST /api/exports/:type` - Request PDF or CSV export
  - `POST /api/ai/narrative` - Request AI commentary (if AI add-on enabled)
- **Receives responses** as JSON with typed schemas (TypeScript interfaces)
- **Polls for async results** (exports, AI narratives) or uses WebSocket for real-time updates (optional Phase 2+)

### Stateful vs Stateless

**Mostly stateless** from server perspective:
- Client maintains UI state (current input values, active scenario) in React component state or Redux/Zustand store
- Authenticated users have session cookies/tokens for API calls
- Saved scenarios are persisted in backend; client rehydrates on page load
- Anonymous users store unsaved scenarios in browser `localStorage` (lost if cache cleared)

---

## 2. API Gateway / Backend Services

### Purpose and Responsibilities

The API Gateway layer handles all client requests, enforces security and rate limits, and routes requests to appropriate backend services. This layer is responsible for:
- REST API endpoints for calculators, scenarios, users, exports
- Authentication and authorization (session management, tier verification)
- Rate limiting (per user, per IP, per API key for B2B)
- Tier gating (check if user has Pro or AI add-on access)
- Request validation (schema validation, input sanitization)
- Response formatting (consistent JSON structure, error handling)

### Components

- **API Server**: Node.js + TypeScript server (Express or Fastify)
- **Authentication Middleware**: JWT or session-based auth, OAuth integration (Google, Microsoft, GitHub)
- **Rate Limiter**: Redis-backed rate limiting (e.g., 100 requests/minute for Free tier, 1000 for Pro)
- **Tier Gate Middleware**: Checks user's subscription tier against requested features (DSCR metrics require Pro, AI narratives require AI add-on)
- **Request Validators**: JSON schema validators (e.g., AJV) for input validation

### Communication Patterns

- **Receives HTTPS requests** from Client Layer
- **Calls Calculation Engine** via function calls or RPC (same process or microservice)
- **Enqueues jobs** to message queue for async exports and AI requests
- **Reads/writes Data Storage** (PostgreSQL for scenarios/users, Redis for sessions/cache)
- **Sends events** to Analytics/Telemetry layer (calculation performed, export requested, tier upgrade)

### Stateful vs Stateless

**Stateless** (horizontally scalable):
- No in-process state; all state externalized to Redis (sessions, rate limits) and PostgreSQL (scenarios, users)
- Multiple API server instances can run behind load balancer
- Session data stored in Redis with TTL (e.g., 24 hours for anonymous, 30 days for logged-in)

---

## 3. Calculation Engine

### Purpose and Responsibilities

The calculation engine is the core mathematical brain of the platform. It executes financial formulas, validates inputs, and produces calculation results. This layer is responsible for:
- Executing formulas (amortization, DSCR, NPV/IRR, breakeven, etc.) with ±0.1% accuracy vs reference models
- Input validation (reject negative amounts, nonsense rates, invalid date ranges)
- Edge case handling (zero cash flow, infinite DSCR, division by zero)
- Output formatting (currency, percentages, dates, units)
- Version tracking (each formula has semantic version ID for audit trails)

### Components

- **Finance Math Library**: TypeScript modules with pure functions for each formula (e.g., `calculateDSCR`, `calculateNPV`, `calculateBreakeven`)
- **Validators**: Input validators for each calculator type (loan calculator requires positive loan amount, interest rate 0-50%, etc.)
- **Formatters**: Output formatters for currency, percentages, dates (locale-aware per Section 1.4)
- **Regression Test Suite**: Golden test scenarios with expected outputs (run on each deployment)

### Communication Patterns

- **Called by API Gateway** via function calls (same Node.js process) or RPC (if microservice)
- **Inputs**: Typed JavaScript objects (e.g., `LoanInputs` interface with `amount`, `rate`, `term`)
- **Outputs**: Typed JavaScript objects (e.g., `LoanResults` with `monthlyPayment`, `totalInterest`, `dscr`, `amortizationSchedule`)
- **No external dependencies** for core math (no database calls, no network calls)
- **Idempotent**: Same inputs always produce same outputs (deterministic, no randomness)

### Stateful vs Stateless

**Purely stateless**:
- Pure functions with no side effects
- No database reads/writes within calculation logic
- Thread-safe and horizontally scalable (can run multiple calculation workers in parallel)

---

## 4. Data Storage

### Purpose and Responsibilities

The data storage layer persists all application data: scenarios, users, subscriptions, sessions, export files, and analytics events. This layer is responsible for:
- Storing saved scenarios with inputs, outputs, metadata (user ID, timestamp, version)
- User accounts, authentication credentials, subscription tiers
- Session management for logged-in and anonymous users
- Caching calculation results and export files (temporary)
- Analytics event storage for Business Intelligence Dashboard

### Components

- **PostgreSQL**: Primary relational database for scenarios, users, subscriptions, calculator configs
  - Tables: `users`, `scenarios`, `subscriptions`, `calculator_configs`, `export_jobs`
  - JSONB columns for flexible scenario inputs/outputs (schemaless per calculator type)
- **Redis**: In-memory cache and session store
  - Sessions: user sessions, anonymous sessions (24-hour TTL)
  - Cache: calculation results (5-minute TTL), rate limit counters
- **S3/Cloudflare R2**: Object storage for export files (PDFs, CSVs)
  - Temporary exports: 24-hour retention for anonymous users
  - Permanent exports: 24-month retention for logged-in users (per Section 1.6)
- **Analytics Database** (optional): Separate PostgreSQL or ClickHouse for high-volume telemetry events

### Communication Patterns

- **Read/write by API Gateway**: Save scenarios, load user profiles, check subscription tiers
- **Read by Calculation Engine**: Load calculator configs (rare, mostly cached)
- **Write by Export/Reporting Services**: Save export files to S3/R2, update export job status in PostgreSQL
- **Write by Analytics/Telemetry**: Log events to analytics database (async, non-blocking)

### Stateful vs Stateless

**Stateful** (managed services or replicated clusters):
- PostgreSQL: Primary-replica setup with automatic failover (AWS RDS, Railway PostgreSQL, or self-managed)
- Redis: Replicated Redis cluster or managed service (AWS ElastiCache, Upstash, Redis Cloud)
- S3/R2: Fully managed object storage (stateless from application perspective)

---

## 5. Export/Reporting Services

### Purpose and Responsibilities

The export/reporting layer generates PDF, CSV, and Excel files from calculation results. This layer is responsible for:
- PDF generation with professional templates (headers, footers, version stamps, branding)
- CSV/Excel generation with proper formatting (column headers, units, metadata)
- Async job processing for large exports (multi-scenario PDFs, 10K+ row CSVs)
- File storage and retrieval (upload to S3/R2, generate signed download URLs)
- White-label customization (B2B client branding, custom disclaimers)

### Components

- **PDF Generator**: Server-side rendering engine (Puppeteer, Playwright, or wkhtmltopdf)
  - Template engine: Handlebars, EJS, or React Server Components for PDF layouts
  - Logo injection, color theming, footer customization per tier/tenant
- **CSV/Excel Generator**: Libraries like `csv-writer`, `exceljs` for structured data exports
- **Export Queue Worker**: Pulls export jobs from message queue (BullMQ, AWS SQS), generates files, uploads to S3
- **Template Library**: Reusable PDF/CSV templates for each calculator type

### Communication Patterns

- **Triggered by API Gateway** via message queue:
  - API Gateway enqueues export job: `{ calculatorId, scenarioId, exportType: 'pdf', userId, tier }`
  - Export worker picks up job, generates file, uploads to S3, updates job status in PostgreSQL
- **Returns signed download URL** to client (S3 presigned URL, valid for 1 hour)
- **Fallback to sync generation** for small exports (single-scenario PDF < 3 seconds per Section 1.6)

### Stateful vs Stateless

**Stateless workers** (horizontally scalable):
- Workers are stateless; can scale up/down based on queue depth
- Job state stored in PostgreSQL (`export_jobs` table with status: pending, processing, completed, failed)
- Generated files stored in S3/R2 (stateless from worker perspective)

---

## 6. AI Services

### Purpose and Responsibilities

The AI services layer generates plain-language narratives, risk commentary, and scenario suggestions using LLM APIs (OpenAI, Anthropic). This layer is responsible for:
- Prompt management (templated prompts per calculator type)
- LLM API calls (send calculation results + prompt, receive narrative text)
- Response formatting (strip unwanted formatting, inject disclaimers)
- Timeout handling (10-second hard cap per Section 1.6)
- Cost tracking and rate limiting (prevent runaway LLM costs)
- Redaction of sensitive data (scrub PII before sending to LLM)

### Components

- **Prompt Manager**: Library of prompt templates per calculator (e.g., "Explain DSCR of {dscr} to a business owner")
- **LLM Client**: API client for OpenAI, Anthropic, or other LLM providers
- **Response Formatter**: Post-processes LLM responses (add disclaimers, convert markdown to HTML, truncate if too long)
- **Redaction Service**: Scrubs scenario data before sending to LLM (remove customer names, proprietary product codes if present)
- **AI Queue Worker**: Async processing of AI requests (optional, can also be synchronous with timeout)

### Communication Patterns

- **Triggered by API Gateway** or enqueued for async processing:
  - Sync: Client requests AI narrative → API Gateway calls AI service → returns narrative within 3 seconds (p95 per Section 1.6)
  - Async: API Gateway enqueues AI job → worker processes, stores result in Redis cache → client polls for result
- **Calls external LLM API** (OpenAI, Anthropic) via HTTPS
- **Logs all requests/responses** to Analytics/Telemetry (for quality monitoring, abuse detection)

### Stateful vs Stateless

**Stateless** (with caching):
- No persistent state; workers are ephemeral
- Cache AI responses in Redis (keyed by calculation inputs hash, 1-hour TTL) to avoid duplicate LLM calls
- Rate limits enforced via Redis counters (50 requests/month per user for AI add-on)

---

## 7. Analytics/Telemetry

### Purpose and Responsibilities

The analytics/telemetry layer collects, stores, and processes usage events for Business Intelligence Dashboard (Section 1.8), product analytics, and error monitoring. This layer is responsible for:
- Event tracking (calculator usage, conversions, exports, AI requests)
- Error logging and monitoring (exceptions, API errors, calculation failures)
- Performance metrics (API latency, calculation time, export time)
- User behavior analytics (conversion funnels, feature adoption, retention cohorts)
- Data anonymization (pseudonymous user IDs, no PII per Section 1.6)

### Components

- **Analytics Client SDK**: Client-side and server-side JavaScript library for tracking events
  - Client events: page views, calculator loads, input changes, export clicks
  - Server events: calculation performed, scenario saved, tier upgrade, export completed
- **Event Ingestion API**: Receives events from clients and servers, validates, enriches, stores
- **Analytics Database**: PostgreSQL (for low-volume) or ClickHouse (for high-volume) time-series event storage
- **Error Monitoring**: Sentry, Datadog, or similar for exception tracking and alerting
- **Metrics Dashboard**: Internal BI Dashboard (Section 1.8) queries analytics database

### Communication Patterns

- **Receives events** from all layers:
  - Client Layer: User interactions, page views
  - API Gateway: API requests, tier checks, auth events
  - Calculation Engine: Calculation performed (calculator ID, inputs hash, latency)
  - Export Services: Export requested, export completed, export failed
  - AI Services: AI request, LLM cost, response time
- **Batches events** (send every 10 seconds or 100 events, whichever comes first) to reduce network overhead
- **Async processing** (non-blocking; event loss is acceptable for non-critical analytics)

### Stateful vs Stateless

**Stateless ingestion** (scalable):
- Event ingestion API is stateless; writes to database or message queue
- Analytics database is stateful (PostgreSQL, ClickHouse, or data warehouse)
- Events stored with retention policy (12 months per Section 1.6, then auto-purged)

---

## Data Flow Example: User Calculates Business Loan DSCR

1. **Client Layer**: User enters loan amount ($200K), rate (7.5%), term (5 years), and operating income ($50K/month) in Business Loan Calculator
2. **Client Layer** → **API Gateway**: `POST /api/calculators/business-loan/calculate` with inputs JSON
3. **API Gateway**: Validates inputs, checks user tier (Pro required for DSCR), authenticates user
4. **API Gateway** → **Calculation Engine**: Calls `calculateLoan(inputs)` function
5. **Calculation Engine**: Computes monthly payment ($4,000), total interest ($40K), DSCR (1.32), returns results JSON
6. **Calculation Engine** → **API Gateway**: Returns calculation results
7. **API Gateway** → **Client Layer**: Returns results JSON (including DSCR since user is Pro tier)
8. **API Gateway** → **Analytics/Telemetry**: Logs event: `calculation_performed` with calculator ID, user ID, latency
9. **Client Layer**: Renders results table, displays DSCR with green indicator (above 1.25 threshold)
10. **(If AI add-on enabled)** User clicks "Explain DSCR" → **API Gateway** → **AI Services**: Generates narrative ("Your DSCR of 1.32 is above typical lender thresholds...") → returns to client

**Total latency**: 100-150ms (API + calculation + response), well under 150ms p95 SLA (Section 1.6)

---

## Summary

This 7-layer architecture provides clear separation of concerns, supports horizontal scaling at each layer, and meets the performance SLAs defined in Section 1.6. Key design principles:
- **Stateless where possible** (API Gateway, Calculation Engine, Export Workers, AI Services) for horizontal scalability
- **Managed state externalized** (PostgreSQL, Redis, S3) to dedicated storage layers
- **Async processing** for heavy workloads (exports, AI) to avoid blocking API requests
- **Modular components** (shared calculation engine, UI components, export templates) to accelerate calculator development
