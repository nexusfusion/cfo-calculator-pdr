# 12.1 Assembly Line Architecture

## Overview

The JSON Assembly Line is the core system that enables rapid creation and deployment of calculators from simple JSON configuration files. This architecture transforms the calculator development process from weeks of custom coding to minutes of configuration, enabling the platform to scale from 8 MVP calculators to 450+ calculators.

**Core principle:** One JSON file = one fully functional calculator, deployed in 5-10 minutes.

**Key benefits:**
- **Speed:** 5-10 minutes from JSON creation to live calculator
- **Consistency:** All calculators follow the same design patterns (Section 4)
- **Maintainability:** Centralized formula library, no code duplication
- **Quality:** Automated validation and testing before deployment
- **Scale:** Non-technical team members can create calculators

---

## System Components

### 1. JSON Configuration Files

**Purpose:** The single source of truth for each calculator.

**Location structure:**
```
/calculators/configs/
  ├── business-loan-dscr.json
  ├── sba-7a-analyzer.json
  ├── equipment-lease-buy.json
  ├── cash-runway.json
  └── [450+ more calculators]
```

**Key characteristics:**
- **One file per calculator** – Each JSON file defines a complete calculator
- **Version controlled** – Stored in Git, full change history
- **Human-readable** – Non-developers can understand and edit
- **Self-documenting** – Field names and structure are intuitive
- **Lightweight** – Typical size: 5-15 KB per calculator

**Example minimal structure:**
```json
{
  "calculator_meta": {
    "calculator_slug": "simple-loan-payment",
    "calculator_name": "Simple Loan Payment Calculator",
    "calculator_version": "1.0.0",
    "category": "financing-lending"
  },
  "inputs": [...],
  "calculations": [...],
  "outputs": {...}
}
```

**Validation:** Every JSON file is validated against the schema (Section 12.2) before deployment.

---

### 2. Calculator Engine (Processor)

**Purpose:** The brain of the assembly line that transforms JSON into working calculators.

**Core responsibilities:**

1. **Schema Validation**
   - Validates JSON against schema (Section 12.2)
   - Ensures all required fields are present
   - Checks data types and constraints
   - Returns detailed error messages if invalid

2. **Component Generation**
   - Reads `inputs` section → generates React input components
   - Reads `outputs` section → generates result cards
   - Reads `warnings` section → generates alert components
   - Applies design system (Section 4) automatically

3. **Formula Wiring**
   - Reads `calculations` section
   - Maps calculation steps to formula library functions
   - Manages data flow between calculation steps
   - Handles dependencies (step B needs output from step A)

4. **Tier Gating Application**
   - Reads `tier_config` section
   - Applies feature flags based on user tier
   - Hides/shows metrics according to tier rules
   - Enforces scenario limits

5. **Export Template Creation**
   - Reads `export_config` section
   - Generates PDF layout templates
   - Creates CSV column definitions
   - Includes watermarks for Free tier

**Technology:**
- TypeScript for type safety
- Runtime validation using Zod or similar
- Caching for frequently used calculators
- Error handling with detailed logging

**Performance:**
- Calculator JSON parsed at build time (not runtime)
- Generated components cached
- First calculation: < 300ms (including UI update)

---

### 3. Formula Library

**Purpose:** Centralized, versioned, tested mathematical functions that calculators call.

**Key characteristics:**
- **Pure functions** – No side effects, deterministic results
- **Versioned** – Formula library has semantic versioning (v1.0.0, v1.1.0)
- **Tested** – Each formula has golden scenarios (Section 10.2)
- **Reusable** – One formula, many calculators

**Formula categories:**
1. Loan & Debt (calculateMonthlyPayment, calculateDSCR, etc.)
2. Cash Flow (calculateBurnRate, calculateRunway, etc.)
3. Profitability (calculateContributionMargin, calculateBreakeven, etc.)
4. Valuation (calculateNPV, calculateIRR, etc.)
5. Utilities (formatCurrency, validatePositive, etc.)

**Example formula interface:**
```typescript
interface FormulaFunction {
  name: string;
  version: string;
  inputs: Array<{name: string; type: string; required: boolean}>;
  output: {type: string; structure?: object};
  execute: (...args: any[]) => any;
}
```

**How calculators call formulas:**
```json
{
  "step_id": "calc_monthly_payment",
  "formula_function": "calculateMonthlyPayment",
  "inputs": ["loan_amount", "interest_rate", "term_years"],
  "output_variable": "monthly_payment"
}
```

The Calculator Engine looks up `calculateMonthlyPayment` in the Formula Library, passes the input values, and stores the result in `monthly_payment` for use in subsequent steps.

**Detailed specifications:** See Section 12.3 for complete formula library API.

---

### 4. UI Generator

**Purpose:** Automatically creates React components from JSON configuration.

**Input-to-Component mapping:**

| JSON input type | Generated component | Design system reference |
|-----------------|---------------------|-------------------------|
| `number` | Number input with validation | Section 4.2 |
| `currency` | Currency input with $ symbol | Section 4.2 |
| `percentage` | Percentage input with % symbol | Section 4.2 |
| `dropdown` | Select dropdown | Section 4.2 |
| `slider` | Range slider with live value | Section 4.2 |

**Output-to-Component mapping:**

| JSON output type | Generated component | Visual style |
|------------------|---------------------|--------------|
| `key_metrics` | Large result card | Primary color, large font |
| `advanced_metrics` | Standard result card | Secondary color, standard font |
| `chart` | Chart component | Uses design tokens |

**Warning-to-Component mapping:**

| JSON severity | Generated component | Visual treatment |
|---------------|---------------------|------------------|
| `info` | Blue alert box | Informational icon |
| `warning` | Yellow alert box | Warning icon |
| `danger` | Red alert box | Error icon |

**Component generation process:**
```
JSON inputs array
  ↓
For each input:
  1. Determine component type (currency, percentage, etc.)
  2. Apply validation rules (min, max, required)
  3. Add tooltip if provided
  4. Wire onChange handler to state management
  5. Apply design system styles (Section 4.3)
  ↓
Generated React component tree
```

**Benefits:**
- **Consistency:** All calculators use identical UI patterns
- **Accessibility:** ARIA labels auto-generated from field names
- **Responsive:** Mobile-first design applied automatically
- **Themeable:** Design tokens (Section 4.3) applied uniformly

---

### 5. Validation Engine

**Purpose:** Catch errors before calculators go live.

**Validation types:**

1. **Schema Validation (Build Time)**
   - Is the JSON syntactically valid?
   - Does it match the schema structure? (Section 12.2)
   - Are all required fields present?
   - Are data types correct?

2. **Formula Validation (Build Time)**
   - Do all referenced formula functions exist in the library?
   - Do input counts match formula signatures?
   - Are output variable names unique?

3. **Tier Config Validation (Build Time)**
   - Are tier rules logically consistent?
   - Do referenced metric_ids exist in outputs?
   - Are scenario limits valid?

4. **Golden Scenario Validation (Build Time, Optional)**
   - If a `golden_scenarios.json` file exists alongside the calculator JSON
   - Run calculations with golden inputs
   - Compare outputs to expected values
   - Fail build if outputs don't match within tolerance (±0.01 for currency)

**Example golden scenario validation:**
```json
// golden_scenarios.json
{
  "scenarios": [
    {
      "name": "Standard 7% loan",
      "inputs": {
        "loan_amount": 100000,
        "interest_rate": 7.0,
        "term_years": 10
      },
      "expected_outputs": {
        "monthly_payment": 1161.08,
        "total_interest": 39329.60
      }
    }
  ]
}
```

If validation fails, build stops and detailed error report is generated.

**Error reporting:**
- Line number where error occurred (for schema errors)
- Which formula is missing (for formula errors)
- Which expected output doesn't match (for golden scenario errors)
- Suggested fixes

---

### 6. Deployment System

**Purpose:** Automated pipeline from Git commit to live calculator.

**Deployment flow:**

```
Developer commits JSON
  ↓
Git push to feature branch
  ↓
CI/CD triggered (GitHub Actions)
  ↓
Validation Engine runs
  ├─ Schema validation
  ├─ Formula validation
  ├─ Tier config validation
  └─ Golden scenario validation (if exists)
  ↓
All validations pass?
  ├─ YES → Merge to main allowed
  └─ NO → Build fails, PR blocked
  ↓
Merge to main branch
  ↓
Production build triggered
  ├─ UI components generated
  ├─ Formula library wired
  ├─ Export templates created
  └─ WordPress shortcode generated
  ↓
Deploy to production (blue-green)
  ↓
Health check + smoke test
  ↓
Calculator live in < 10 minutes
```

**WordPress shortcode auto-generation:**
When a calculator deploys, the system automatically generates a WordPress shortcode:

```
[cfo_calculator slug="business-loan-dscr"]
```

This shortcode is documented in `/docs/wordpress-shortcodes.md` with usage instructions.

**Rollback process:**
- Revert Git commit
- Previous version re-deployed automatically
- Takes < 5 minutes
- Zero downtime (blue-green deployment)

---

## Data Flow Diagram

```
┌──────────────────────────────────────────────────────────────────┐
│ 1. CONFIGURATION LAYER (JSON Files)                             │
│                                                                  │
│  /calculators/configs/business-loan-dscr.json                   │
│  ├─ calculator_meta                                             │
│  ├─ inputs (loan_amount, interest_rate, etc.)                  │
│  ├─ calculations (call formula library)                        │
│  ├─ outputs (monthly_payment, dscr, etc.)                      │
│  ├─ warnings (conditional alerts)                              │
│  ├─ tier_config (feature gating rules)                         │
│  └─ export_config (PDF/CSV templates)                          │
└────────────────────┬─────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 2. VALIDATION LAYER (Build Time)                                │
│                                                                  │
│  Validation Engine                                              │
│  ├─ Schema validation (Zod/JSON Schema)                        │
│  ├─ Formula existence check                                     │
│  ├─ Tier config validation                                      │
│  └─ Golden scenario testing (if provided)                      │
│                                                                  │
│  Result: PASS → Continue | FAIL → Block deployment             │
└────────────────────┬─────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 3. GENERATION LAYER (Build Time)                                │
│                                                                  │
│  UI Generator                    Formula Wiring Engine          │
│  ├─ Input components    +        ├─ Parse calculations array   │
│  ├─ Output cards                 ├─ Map to formula library     │
│  └─ Warning components           └─ Create execution DAG       │
│                                                                  │
│  Export Generator                                                │
│  ├─ PDF template                                                │
│  └─ CSV structure                                               │
└────────────────────┬─────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 4. RUNTIME LAYER (User Interaction)                             │
│                                                                  │
│  User enters inputs → React state updated                       │
│         ↓                                                        │
│  Trigger calculation → Calculator Engine                        │
│         ↓                                                        │
│  Execute formula steps in order:                                │
│    Step 1: calculateMonthlyPayment(inputs) → monthly_payment    │
│    Step 2: calculateDSCR(monthly_payment, noi) → dscr          │
│         ↓                                                        │
│  Apply tier gating → Show/hide outputs based on user tier      │
│         ↓                                                        │
│  Evaluate warnings → Show alerts if conditions met             │
│         ↓                                                        │
│  Render results → Update UI (< 300ms total)                    │
└────────────────────┬─────────────────────────────────────────────┘
                     │
                     ▼
┌──────────────────────────────────────────────────────────────────┐
│ 5. EXPORT LAYER (PDF/CSV Generation)                            │
│                                                                  │
│  User clicks "Export to PDF"                                    │
│         ↓                                                        │
│  Export Engine reads export_config from JSON                    │
│         ↓                                                        │
│  Generate PDF using template + current scenario data           │
│         ↓                                                        │
│  Apply watermark if Free tier                                   │
│         ↓                                                        │
│  Return PDF (< 3 seconds, p95 SLA from Section 1.6)           │
└──────────────────────────────────────────────────────────────────┘
```

---

## Time to Deploy: 5-10 Minutes

**Breakdown:**

| Step | Time | Notes |
|------|------|-------|
| Create JSON config | 3-5 min | Copy from template, fill in fields |
| Commit to Git | 30 sec | Standard git workflow |
| CI/CD validation | 1-2 min | Automated schema + formula checks |
| Build and deploy | 2-3 min | UI generation, formula wiring, deployment |
| Health check | 30 sec | Automated smoke test |
| **TOTAL** | **7-11 min** | **Typically ~10 minutes** |

**Comparison to custom development:**

| Approach | Time to Deploy | Lines of Code | Maintainability |
|----------|----------------|---------------|-----------------|
| Custom React component | 2-4 weeks | 500-1000 lines | Hard (unique code per calculator) |
| JSON Assembly Line | 5-10 minutes | 50-100 lines JSON | Easy (centralized formula library) |

**Scalability:**
- **8 calculators (MVP):** ~2 hours total to create all JSON configs
- **450+ calculators:** ~75 hours (~2 weeks for one person)
- **Maintenance:** Update formula library once, all calculators benefit

---

## Benefits Over Custom Development

### Speed
- **Before:** 2-4 weeks to build a custom calculator
- **After:** 5-10 minutes to deploy from JSON

### Consistency
- **Before:** Each calculator had unique UI/UX patterns
- **After:** All calculators use identical design system (Section 4)

### Quality
- **Before:** Manual testing, easy to miss edge cases
- **After:** Automated validation, golden scenarios enforce correctness

### Maintainability
- **Before:** 450 calculators × 500 lines = 225,000 lines of code to maintain
- **After:** 450 JSON files + 1 formula library (shared code)

### Iteration Speed
- **Before:** Bug fix requires updating 450+ code files
- **After:** Fix formula library once, all calculators updated

### Non-Technical Contribution
- **Before:** Only developers can create calculators
- **After:** Product managers can create calculators from JSON templates

---

## Architecture Principles

### 1. Separation of Concerns
- **Configuration (JSON)** – What the calculator does
- **Logic (Formula Library)** – How calculations are performed
- **Presentation (UI Generator)** – How results are displayed
- **Infrastructure (Deployment)** – How it gets to production

### 2. Convention Over Configuration
- Default behaviors applied automatically
- Only specify exceptions in JSON
- Example: All currency inputs get $ symbol automatically

### 3. Fail-Fast Validation
- Catch errors at build time, not runtime
- Block deployment if validation fails
- Detailed error messages for quick fixes

### 4. Progressive Enhancement
- Start with simple JSON (minimal fields)
- Add complexity as needed (warnings, AI config, export config)
- Calculators work with minimal configuration

### 5. Version Everything
- Calculator JSON has semantic versions
- Formula library has semantic versions
- Breaking changes trigger major version bumps
- Backward compatibility maintained for 2 major versions

---

## Integration with Other Systems

### WordPress Integration
- Auto-generated shortcodes: `[cfo_calculator slug="calculator-name"]`
- Shortcode accepts parameters: `tier="pro"`, `hide_export="true"`
- Responsive embed, inherits WordPress theme styles

### Analytics Integration (Section 7)
- Standard events tracked automatically for all calculators
- Custom events defined in JSON analytics_config (optional)
- All events follow event taxonomy (Section 7.1)

### AI Integration (Section 8)
- Optional ai_config section in JSON
- If present, "Generate AI Narrative" button added automatically
- AI prompt template uses calculator-specific context

### Tier Gating (Section 6)
- tier_config section defines what's visible per tier
- Feature flags applied automatically by Calculator Engine
- Upgrade prompts shown for gated features

---

## Next Steps

- **Section 12.2:** Complete JSON schema specification with all field definitions
- **Section 12.3:** Formula library API with function signatures and examples
- **Section 12.4:** Detailed deployment pipeline with CI/CD configuration
- **Section 12.5:** Complete JSON examples for 3 calculator types
