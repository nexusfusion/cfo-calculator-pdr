# 12.3 Formula Library API

## Overview

The Formula Library is a centralized, versioned collection of pure mathematical functions that all calculators can call. This library is the computational backbone of the JSON Assembly Line system.

**Key principles:**
- **Pure functions** – No side effects, same inputs always produce same outputs
- **Versioned** – Formula library has semantic versioning (v1.0.0, v1.1.0, etc.)
- **Tested** – Each formula has golden scenarios ensuring correctness
- **Reusable** – Write once, use in 450+ calculators
- **Type-safe** – Strict input/output contracts with TypeScript

**Current version:** v1.0.0
**Location:** `/src/lib/formulas/`
**Language:** TypeScript

---

## Formula Structure

Every formula in the library follows this structure:

```typescript
interface FormulaMetadata {
  name: string;              // Function name (camelCase)
  version: string;           // Semantic version when introduced
  category: string;          // Formula category
  description: string;       // What this formula calculates
  introduced: string;        // Library version when added
  lastModified: string;      // Library version when last changed
}

interface FormulaContract {
  inputs: Array<{
    name: string;            // Parameter name
    type: string;            // TypeScript type
    required: boolean;       // Is this parameter required?
    default?: any;           // Default value if optional
    validation?: {           // Validation rules
      min?: number;
      max?: number;
      mustBePositive?: boolean;
    };
  }>;
  output: {
    type: string;            // Return type
    structure?: object;      // Structure if returning object
  };
}

interface Formula {
  metadata: FormulaMetadata;
  contract: FormulaContract;
  execute: (...args: any[]) => any;
}
```

---

## Formula Categories

### 1. Loan & Debt Formulas

#### calculateMonthlyPayment

**Description:** Calculate monthly payment for an amortizing loan using standard loan payment formula.

**Formula:**
```
P = L × [r(1+r)^n] / [(1+r)^n - 1]

Where:
  P = Monthly payment
  L = Loan principal
  r = Monthly interest rate (annual rate / 12 / 100)
  n = Number of payments (term in months)
```

**Function signature:**
```typescript
function calculateMonthlyPayment(
  principal: number,
  annualRate: number,
  termMonths: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| principal | number | Yes | Loan amount in dollars | > 0 |
| annualRate | number | Yes | Annual interest rate as percentage (e.g., 7.5) | 0.01 - 30 |
| termMonths | number | Yes | Loan term in months | > 0, integer |

**Returns:** Monthly payment amount (number)

**Edge cases:**
- If annualRate = 0: Return principal / termMonths (interest-free loan)
- If principal ≤ 0: Throw error "Principal must be positive"
- If termMonths ≤ 0: Throw error "Term must be positive"

**Example usage:**
```typescript
const payment = calculateMonthlyPayment(100000, 7.5, 120);
// Returns: 1161.08
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateTotalInterest

**Description:** Calculate total interest paid over the life of a loan.

**Formula:**
```
Total Interest = (Monthly Payment × Number of Payments) - Principal
```

**Function signature:**
```typescript
function calculateTotalInterest(
  monthlyPayment: number,
  termMonths: number,
  principal: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| monthlyPayment | number | Yes | Monthly payment amount | > 0 |
| termMonths | number | Yes | Loan term in months | > 0, integer |
| principal | number | Yes | Original loan amount | > 0 |

**Returns:** Total interest paid (number)

**Example usage:**
```typescript
const totalInterest = calculateTotalInterest(1161.08, 120, 100000);
// Returns: 39329.60
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateAmortizationSchedule

**Description:** Generate a complete amortization schedule with principal/interest breakdown for each payment.

**Function signature:**
```typescript
function calculateAmortizationSchedule(
  principal: number,
  annualRate: number,
  termMonths: number
): AmortizationSchedule
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| principal | number | Yes | Loan amount in dollars | > 0 |
| annualRate | number | Yes | Annual interest rate as percentage | 0.01 - 30 |
| termMonths | number | Yes | Loan term in months | > 0, integer |

**Returns:** AmortizationSchedule object

```typescript
interface AmortizationSchedule {
  monthlyPayment: number;
  totalInterest: number;
  totalCost: number;
  schedule: Array<{
    month: number;
    payment: number;
    principal: number;
    interest: number;
    balance: number;
  }>;
}
```

**Example usage:**
```typescript
const schedule = calculateAmortizationSchedule(100000, 7.5, 120);
// Returns object with monthlyPayment: 1161.08 and 120-row schedule array
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateDSCR

**Description:** Calculate Debt Service Coverage Ratio, a key metric for commercial lending.

**Formula:**
```
DSCR = Net Operating Income / Annual Debt Service

Where:
  Net Operating Income = Revenue - Operating Expenses (excluding debt payments)
  Annual Debt Service = Total annual loan payments (principal + interest)
```

**Function signature:**
```typescript
function calculateDSCR(
  netOperatingIncome: number,
  annualDebtService: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| netOperatingIncome | number | Yes | Annual NOI in dollars | Can be negative |
| annualDebtService | number | Yes | Annual debt payments in dollars | > 0 |

**Returns:** DSCR as ratio (number, typically 0.5 - 5.0)

**Edge cases:**
- If annualDebtService = 0: Throw error "Annual debt service must be positive"
- If NOI is negative: Return negative DSCR (valid, indicates inability to cover debt)

**Example usage:**
```typescript
const dscr = calculateDSCR(300000, 210000);
// Returns: 1.43 (meaning NOI is 1.43x annual debt service)
```

**Interpretation guidance:**
- DSCR < 1.0: Insufficient income to cover debt (red flag)
- DSCR 1.0 - 1.25: Tight coverage, risky for lenders
- DSCR 1.25 - 1.5: Minimum acceptable for most lenders
- DSCR > 1.5: Strong coverage, favorable for approval

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateEffectiveAPR

**Description:** Calculate effective Annual Percentage Rate including all fees and costs.

**Formula:**
```
Effective APR = [(Total Cost / Principal) / Term in Years] × 100
```

**Function signature:**
```typescript
function calculateEffectiveAPR(
  principal: number,
  totalCost: number,
  termMonths: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| principal | number | Yes | Original loan/financing amount | > 0 |
| totalCost | number | Yes | Total cost including all fees and interest | > principal |
| termMonths | number | Yes | Term in months | > 0, integer |

**Returns:** Effective APR as percentage (number)

**Example usage:**
```typescript
const effectiveAPR = calculateEffectiveAPR(100000, 139329.60, 120);
// Returns: 4.72% annualized effective rate
```

**Version history:**
- v1.0.0: Initial implementation

---

### 2. Cash Flow Formulas

#### calculateBurnRate

**Description:** Calculate monthly cash burn rate (how much cash is consumed per month).

**Formula:**
```
Burn Rate = Monthly Expenses - Monthly Revenue
```

**Function signature:**
```typescript
function calculateBurnRate(
  monthlyRevenue: number,
  monthlyExpenses: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| monthlyRevenue | number | Yes | Average monthly revenue | ≥ 0 |
| monthlyExpenses | number | Yes | Average monthly expenses | ≥ 0 |

**Returns:** Monthly burn rate (number, positive = burning cash, negative = generating cash)

**Example usage:**
```typescript
const burnRate = calculateBurnRate(50000, 75000);
// Returns: 25000 (burning $25k/month)

const burnRate2 = calculateBurnRate(100000, 75000);
// Returns: -25000 (generating $25k/month)
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateRunway

**Description:** Calculate cash runway in months (how long until cash runs out).

**Formula:**
```
Runway = Cash Balance / Monthly Burn Rate

(Only applicable if burning cash, i.e., burn rate > 0)
```

**Function signature:**
```typescript
function calculateRunway(
  cashBalance: number,
  monthlyBurn: number
): number | null
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| cashBalance | number | Yes | Current cash on hand | ≥ 0 |
| monthlyBurn | number | Yes | Monthly cash burn (positive number) | Can be any number |

**Returns:**
- Number of months (number) if burning cash
- null if generating cash (monthlyBurn ≤ 0)

**Edge cases:**
- If monthlyBurn ≤ 0: Return null (not applicable, business is cash-positive)
- If cashBalance = 0: Return 0 (no runway)

**Example usage:**
```typescript
const runway = calculateRunway(150000, 25000);
// Returns: 6 (6 months of runway)

const runway2 = calculateRunway(150000, -10000);
// Returns: null (generating cash, runway not applicable)
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateBreakeven

**Description:** Calculate breakeven point in units or revenue.

**Formula (Units):**
```
Breakeven Units = Fixed Costs / Contribution Margin per Unit

Where:
  Contribution Margin per Unit = Selling Price - Variable Cost per Unit
```

**Formula (Revenue):**
```
Breakeven Revenue = Fixed Costs / Contribution Margin Ratio

Where:
  Contribution Margin Ratio = (Selling Price - Variable Cost) / Selling Price
```

**Function signature:**
```typescript
function calculateBreakeven(
  fixedCosts: number,
  contributionMarginPerUnit: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| fixedCosts | number | Yes | Total fixed costs per period | ≥ 0 |
| contributionMarginPerUnit | number | Yes | Contribution margin per unit sold | > 0 |

**Returns:** Breakeven quantity (number of units)

**Edge cases:**
- If contributionMarginPerUnit ≤ 0: Throw error "Contribution margin must be positive"
- If fixedCosts = 0: Return 0 (breakeven immediately)

**Example usage:**
```typescript
const breakevenUnits = calculateBreakeven(100000, 50);
// Returns: 2000 (need to sell 2,000 units to break even)
```

**Version history:**
- v1.0.0: Initial implementation

---

### 3. Profitability Formulas

#### calculateContributionMargin

**Description:** Calculate contribution margin per unit and contribution margin ratio.

**Formulas:**
```
Contribution Margin per Unit = Selling Price - Variable Cost per Unit
Contribution Margin Ratio = (Selling Price - Variable Cost) / Selling Price × 100
```

**Function signature:**
```typescript
function calculateContributionMargin(
  sellingPrice: number,
  variableCost: number
): ContributionMarginResult
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| sellingPrice | number | Yes | Price per unit | > 0 |
| variableCost | number | Yes | Variable cost per unit | ≥ 0 |

**Returns:** ContributionMarginResult object

```typescript
interface ContributionMarginResult {
  marginPerUnit: number;      // Dollar contribution per unit
  marginRatio: number;        // Contribution margin as percentage
}
```

**Example usage:**
```typescript
const margin = calculateContributionMargin(100, 60);
// Returns: {marginPerUnit: 40, marginRatio: 40.0}
```

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateMarginOfSafety

**Description:** Calculate margin of safety (how far above breakeven current revenue is).

**Formula:**
```
Margin of Safety = (Current Revenue - Breakeven Revenue) / Current Revenue × 100
```

**Function signature:**
```typescript
function calculateMarginOfSafety(
  currentRevenue: number,
  breakevenRevenue: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| currentRevenue | number | Yes | Current revenue per period | > 0 |
| breakevenRevenue | number | Yes | Breakeven revenue per period | > 0 |

**Returns:** Margin of safety as percentage (number)

**Example usage:**
```typescript
const safety = calculateMarginOfSafety(500000, 300000);
// Returns: 40.0 (40% margin of safety)
```

**Interpretation:**
- Negative value: Below breakeven (losing money)
- 0-20%: Low margin of safety, vulnerable to revenue drops
- 20-40%: Moderate safety
- 40%+: Strong margin of safety

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateGrossMargin

**Description:** Calculate gross margin and gross margin percentage.

**Formulas:**
```
Gross Profit = Revenue - Cost of Goods Sold (COGS)
Gross Margin % = (Gross Profit / Revenue) × 100
```

**Function signature:**
```typescript
function calculateGrossMargin(
  revenue: number,
  cogs: number
): GrossMarginResult
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| revenue | number | Yes | Total revenue | > 0 |
| cogs | number | Yes | Cost of goods sold | ≥ 0 |

**Returns:** GrossMarginResult object

```typescript
interface GrossMarginResult {
  grossProfit: number;        // Dollar gross profit
  grossMarginPercent: number; // Gross margin as percentage
}
```

**Example usage:**
```typescript
const margin = calculateGrossMargin(1000000, 600000);
// Returns: {grossProfit: 400000, grossMarginPercent: 40.0}
```

**Version history:**
- v1.0.0: Initial implementation

---

### 4. Valuation Formulas

#### calculateNPV

**Description:** Calculate Net Present Value of a series of cash flows.

**Formula:**
```
NPV = Σ [CFt / (1 + r)^t] - Initial Investment

Where:
  CFt = Cash flow at time t
  r = Discount rate (as decimal, e.g., 0.10 for 10%)
  t = Time period (0, 1, 2, ...)
```

**Function signature:**
```typescript
function calculateNPV(
  cashFlows: number[],
  discountRate: number
): number
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| cashFlows | number[] | Yes | Array of cash flows (year 0, year 1, ...) | Array length > 0 |
| discountRate | number | Yes | Annual discount rate as percentage (e.g., 10 for 10%) | > 0 |

**Returns:** NPV as dollar amount (number)

**Example usage:**
```typescript
const npv = calculateNPV([-100000, 30000, 40000, 50000, 60000], 10);
// Returns: 32,396.61
// (Initial investment -$100k, then $30k, $40k, $50k, $60k over 4 years at 10% discount)
```

**Interpretation:**
- NPV > 0: Investment is profitable at given discount rate
- NPV = 0: Investment breaks even
- NPV < 0: Investment loses money at given discount rate

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateIRR

**Description:** Calculate Internal Rate of Return for a series of cash flows.

**Formula:**
IRR is the discount rate that makes NPV = 0. Solved iteratively using Newton-Raphson method.

**Function signature:**
```typescript
function calculateIRR(
  cashFlows: number[]
): number | null
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| cashFlows | number[] | Yes | Array of cash flows (year 0, year 1, ...) | Must have at least one negative and one positive value |

**Returns:**
- IRR as percentage (number) if solvable
- null if IRR cannot be calculated (e.g., all cash flows same sign)

**Edge cases:**
- If all cash flows are positive or all negative: Return null (no IRR)
- If IRR doesn't converge after 100 iterations: Return null

**Example usage:**
```typescript
const irr = calculateIRR([-100000, 30000, 40000, 50000, 60000]);
// Returns: 22.4% (annual return rate that makes NPV = 0)
```

**Interpretation:**
- IRR > required rate of return: Investment is attractive
- IRR = required rate of return: Investment breaks even
- IRR < required rate of return: Investment is unattractive

**Version history:**
- v1.0.0: Initial implementation

---

#### calculateMultipleValuation

**Description:** Calculate business valuation using multiple-based approach (e.g., revenue multiple, EBITDA multiple).

**Formula:**
```
Valuation Low = Metric × Multiple Low
Valuation High = Metric × Multiple High
Valuation Midpoint = (Valuation Low + Valuation High) / 2
```

**Function signature:**
```typescript
function calculateMultipleValuation(
  metric: number,
  multipleLow: number,
  multipleHigh: number
): ValuationRange
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| metric | number | Yes | Revenue, EBITDA, or other metric | > 0 |
| multipleLow | number | Yes | Low end of multiple range | > 0 |
| multipleHigh | number | Yes | High end of multiple range | ≥ multipleLow |

**Returns:** ValuationRange object

```typescript
interface ValuationRange {
  valuationLow: number;
  valuationHigh: number;
  valuationMidpoint: number;
}
```

**Example usage:**
```typescript
const valuation = calculateMultipleValuation(5000000, 2.5, 4.0);
// Returns: {valuationLow: 12500000, valuationHigh: 20000000, valuationMidpoint: 16250000}
// (Business with $5M revenue valued at 2.5-4.0× revenue = $12.5M - $20M)
```

**Version history:**
- v1.0.0: Initial implementation

---

### 5. Utility Formulas

#### formatCurrency

**Description:** Format a number as US currency with commas and decimal places.

**Function signature:**
```typescript
function formatCurrency(
  value: number,
  decimals: number = 2
): string
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| value | number | Yes | Number to format | Any number |
| decimals | number | No | Decimal places (default: 2) | 0-4 |

**Returns:** Formatted currency string

**Example usage:**
```typescript
formatCurrency(1234567.89);
// Returns: "$1,234,567.89"

formatCurrency(1234567.89, 0);
// Returns: "$1,234,568"
```

**Version history:**
- v1.0.0: Initial implementation

---

#### formatPercentage

**Description:** Format a number as percentage with decimal places.

**Function signature:**
```typescript
function formatPercentage(
  value: number,
  decimals: number = 2
): string
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| value | number | Yes | Number to format (stored as 7.5, not 0.075) | Any number |
| decimals | number | No | Decimal places (default: 2) | 0-4 |

**Returns:** Formatted percentage string

**Example usage:**
```typescript
formatPercentage(7.5);
// Returns: "7.50%"

formatPercentage(7.5, 1);
// Returns: "7.5%"
```

**Version history:**
- v1.0.0: Initial implementation

---

#### validatePositive

**Description:** Validate that a value is positive (> 0).

**Function signature:**
```typescript
function validatePositive(
  value: number,
  fieldName: string
): void
```

**Parameters:**

| Name | Type | Required | Description | Validation |
|------|------|----------|-------------|------------|
| value | number | Yes | Value to validate | - |
| fieldName | string | Yes | Field name for error message | - |

**Returns:** void (throws error if validation fails)

**Example usage:**
```typescript
validatePositive(100, "loan_amount");
// No error, validation passes

validatePositive(-100, "loan_amount");
// Throws: "loan_amount must be positive (received: -100)"
```

**Version history:**
- v1.0.0: Initial implementation

---

#### multiply

**Description:** Multiply two numbers (utility for simple calculations).

**Function signature:**
```typescript
function multiply(
  a: number,
  b: number
): number
```

**Example usage:**
```typescript
const result = multiply(12, 1161.08);
// Returns: 13932.96
```

**Version history:**
- v1.0.0: Initial implementation

---

#### subtract

**Description:** Subtract second number from first (utility for simple calculations).

**Function signature:**
```typescript
function subtract(
  a: number,
  b: number
): number
```

**Example usage:**
```typescript
const result = subtract(139329.60, 100000);
// Returns: 39329.60
```

**Version history:**
- v1.0.0: Initial implementation

---

## Formula Calling from JSON

Calculator JSON files reference formulas by name in the `calculations` array:

```json
{
  "calculations": [
    {
      "step_id": "calc_monthly_payment",
      "formula_function": "calculateMonthlyPayment",
      "inputs": ["loan_amount", "interest_rate", "term_years"],
      "output_variable": "monthly_payment"
    }
  ]
}
```

**How the Calculator Engine processes this:**

1. Parse `formula_function`: "calculateMonthlyPayment"
2. Look up formula in library
3. Validate input count matches formula signature (3 inputs expected)
4. Extract input values from user inputs or previous calculation outputs:
   - `loan_amount` → 100000
   - `interest_rate` → 7.5
   - `term_years` → 10
5. Convert term_years to months: 10 × 12 = 120 (if formula expects months)
6. Call formula: `calculateMonthlyPayment(100000, 7.5, 120)`
7. Store result in `output_variable`: `monthly_payment = 1161.08`

---

## Error Handling

All formulas follow consistent error handling patterns:

### Validation Errors
Thrown when inputs violate validation rules:

```typescript
throw new Error("Principal must be positive (received: -100)");
throw new Error("Term must be a positive integer (received: 0)");
```

### Calculation Errors
Thrown when calculation cannot be performed:

```typescript
throw new Error("Cannot calculate IRR: all cash flows must not have the same sign");
throw new Error("Cannot calculate runway: monthly burn must be positive");
```

### Edge Case Handling
Formulas handle edge cases gracefully:

```typescript
// Interest-free loan
if (annualRate === 0) {
  return principal / termMonths;
}

// Cash-positive business (no runway applicable)
if (monthlyBurn <= 0) {
  return null;
}
```

---

## Testing & Golden Scenarios

Every formula has golden scenarios (test cases with known correct outputs).

**Example golden scenario for calculateMonthlyPayment:**

```json
{
  "formula_name": "calculateMonthlyPayment",
  "test_cases": [
    {
      "name": "Standard 7% loan",
      "inputs": {
        "principal": 100000,
        "annualRate": 7.0,
        "termMonths": 120
      },
      "expected_output": 1161.08,
      "tolerance": 0.01
    },
    {
      "name": "Interest-free loan",
      "inputs": {
        "principal": 120000,
        "annualRate": 0,
        "termMonths": 120
      },
      "expected_output": 1000.00,
      "tolerance": 0.01
    }
  ]
}
```

**Test suite runs:**
- On every formula library code change
- During calculator JSON validation (if calculator has golden scenarios)
- Before deployment to production

---

## Versioning & Backward Compatibility

**Formula Library versioning:**
- Current version: v1.0.0
- Follows semantic versioning

**Version bump rules:**

| Change Type | Version Bump | Example |
|-------------|--------------|---------|
| New formula added | Minor (1.0.0 → 1.1.0) | Add calculateROI() |
| Formula bug fix (no signature change) | Patch (1.0.0 → 1.0.1) | Fix rounding in calculateNPV() |
| Formula signature change | Major (1.0.0 → 2.0.0) | Change calculateMonthlyPayment to require 4th parameter |
| Formula removed | Major (1.0.0 → 2.0.0) | Remove deprecated function |

**Backward compatibility:**
- Calculators specify which formula library version they depend on
- Breaking changes require updating calculator JSON files
- Deprecated formulas maintained for 2 major versions before removal

---

## Adding New Formulas

**Process for adding a new formula:**

1. **Define formula contract** (inputs, outputs, validation)
2. **Write TypeScript implementation** with type safety
3. **Create golden scenarios** with 3-5 test cases
4. **Write documentation** following this format
5. **Add to formula library index** with metadata
6. **Run test suite** to ensure all golden scenarios pass
7. **Increment formula library version** (minor version bump)
8. **Update formula library documentation** (this file)

**Example pull request checklist:**
- [ ] Formula implementation in `/src/lib/formulas/{category}/{formulaName}.ts`
- [ ] Golden scenarios in `/tests/formulas/{formulaName}.test.ts`
- [ ] Documentation added to this file (12.3)
- [ ] Formula added to library index with metadata
- [ ] All tests passing (100% pass rate required)
- [ ] Version bumped in `package.json`

---

## Next Steps

- **Section 12.4:** Deployment pipeline with CI/CD validation
- **Section 12.5:** Complete calculator examples showing formula usage
